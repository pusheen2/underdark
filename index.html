<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Underdark — Act 1</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body { width:100%; height:100%; overflow:hidden; background:#000; touch-action:none; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none; }
canvas { display:block; width:100%; height:100%; image-rendering:pixelated; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
'use strict';

// ── CONFIG ──
const TILE = 32;
const SPEED = 2.2;
const ANIM_SPEED = 0.12;
const INTERACT_DIST = 38;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H, scale = 1;
function resize() {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W; canvas.height = H;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = W * dpr; canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// ── COLORS ──
const C = {
  grass: '#5a9e4b', grassDark: '#3d7a35', path: '#c4a96a', pathEdge: '#a88c4a',
  water: '#4a90c4', waterDeep: '#3670a0',
  wallLight: '#e8dcc8', wallDark: '#b8a888', roof: '#c45050', roofDark: '#963838',
  door: '#8b6b3e', window: '#87ceeb', windowFrame: '#6b5030',
  tree: '#2d6e1e', treeDark: '#1a5010', trunk: '#8b6b3e',
  deadTree: '#5a4a3a', deadLeaf: '#6e5a3a',
  rock: '#888', rockDark: '#666',
  fence: '#c8b080',
  glow: '#a060ff',
  fogColor: 'rgba(20,15,30,',
  sakura: '#ffb7c5',
  // Act 2 — crystal paradise
  crystalGrass: '#7bddaa', crystalGrassDark: '#5aba88',
  crystal: '#bb88ff', crystalDark: '#8855cc', crystalGlow: 'rgba(180,140,255,',
  // Act 3 — corruption
  darkFloor: '#2a1a2a', darkFloorDetail: '#1e0e1e',
  corruptTree: '#3a1a3a', corruptLeaf: '#5a2a5a', corruptBranch: '#2a0a2a',
  voidColor: '#050010',
};

// ── CHARACTERS ──
const CHARS = {
  hikaru: { name:'Hikaru', hair:'#4488ff', hairStyle:'spiky', skin:'#fce4c8', shirt:'#fff', pants:'#334', eyes:'#2255cc' },
  rina:   { name:'Rina',   hair:'#ff6eb4', hairStyle:'long',  skin:'#fce4c8', shirt:'#ff8fa0', pants:'#446', eyes:'#cc3366' },
  kenji:  { name:'Kenji',  hair:'#ff8833', hairStyle:'short', skin:'#f0d0a0', shirt:'#33aa55', pants:'#334', eyes:'#886622' },
  glen:   { name:'Glen',   hair:'#33cc66', hairStyle:'messy', skin:'#fce4c8', shirt:'#667', pants:'#334', eyes:'#228844' },
  officer:{ name:'Officer Tanaka', hair:'#334', hairStyle:'short', skin:'#f0d0a0', shirt:'#2244aa', pants:'#223', eyes:'#332' },
  shopkeeper:{ name:'Mrs. Yamada', hair:'#996', hairStyle:'bun', skin:'#f0d0a0', shirt:'#aa6633', pants:'#556', eyes:'#553' },
  glen_boss: { name:'Glen', hair:'#1a6633', hairStyle:'messy', skin:'#c8b8a0', shirt:'#223', pants:'#112', eyes:'#aa22ff' },
  fairy:     { name:'???', hair:'#aaeeff', hairStyle:'long', skin:'#e8e0ff', shirt:'#ccbbff', pants:'#aaaadd', eyes:'#cc88ff' },
  larry:     { name:'Larry', hair:'#cc9944', hairStyle:'short', skin:'#f0d0a0', shirt:'#aa4444', pants:'#334', eyes:'#556622' },
  larry_fake:{ name:'Larry', hair:'#aa7722', hairStyle:'short', skin:'#d8c090', shirt:'#882222', pants:'#223', eyes:'#880044' },
};

// ── LANGUAGE ──
let lang = localStorage.getItem('underdark-lang') || 'tr';
const STRINGS = {
  // UI
  ui_objective:  { en:'OBJECTIVE', ru:'ЦЕЛЬ', tr:'HEDEF' },
  ui_talk:       { en:'Talk', ru:'Говорить', tr:'Konuş' },
  // Objectives
  obj_talk_friends:     { en:'Talk to your friends', ru:'Поговори с друзьями', tr:'Arkadaşlarınla konuş' },
  obj_go_town:          { en:'Head east to the town center →', ru:'Иди на восток к центру города →', tr:'Şehir merkezine doğuya git →' },
  obj_go_forest:        { en:'Follow the clue to the old forest →', ru:'Следуй за уликой к старому лесу →', tr:'İpucunu takip et, eski ormana git →' },
  obj_find_light:       { en:'Find the source of the strange light', ru:'Найди источник странного света', tr:'Garip ışığın kaynağını bul' },
  obj_investigate_town: { en:'Investigate the town for clues', ru:'Ищи улики в городе', tr:'Şehirde ipucu ara' },
  obj_search_forest:    { en:'Search the forest for Glen', ru:'Ищи Глена в лесу', tr:'Ormanda Glen\'i ara' },
  // Title screen
  title_name:     { en:'UNDERDARK', ru:'UNDERDARK', tr:'UNDERDARK' },
  title_subtitle: { en:'Act 1: The Disappearance', ru:'Акт 1: Исчезновение', tr:'Perde 1: Kaybolma' },
  title_tap:      { en:'Tap to Start', ru:'Нажми, чтобы начать', tr:'Başlamak için dokun' },
  title_credit:   { en:'A School Project', ru:'Школьный проект', tr:'Bir Okul Projesi' },
  // Ending screen
  end_awaits: { en:'The Underdark awaits...', ru:'Андердарк ждёт...', tr:'Underdark bekliyor...' },
  end_line1:  { en:'Three friends step into the unknown', ru:'Трое друзей шагают в неизвестность', tr:'Üç arkadaş bilinmeze adım atıyor' },
  end_line2:  { en:'to save the one they lost.', ru:'чтобы спасти того, кого потеряли.', tr:'kaybettikleri kişiyi kurtarmak için.' },
  end_act:    { en:'End of Act 1', ru:'Конец 1 Акта', tr:'1. Perde Sonu' },
  end_cont:   { en:'To be continued...', ru:'Продолжение следует...', tr:'Devamı gelecek...' },
  // Character names
  name_officer:    { en:'Officer Tanaka', ru:'Офицер Танака', tr:'Memur Tanaka' },
  name_shopkeeper: { en:'Mrs. Yamada', ru:'Госпожа Ямада', tr:'Bayan Yamada' },
  // Dialogue — Neighborhood: Rina
  dlg_rina_repeat:  { en:"We should check the town center. Maybe someone saw Glen.", ru:"Нам нужно проверить центр города. Может, кто-то видел Глена.", tr:"Şehir merkezine bakmalıyız. Belki birisi Glen'i görmüştür." },
  dlg_rina_1:       { en:"Hikaru! Have you heard? Glen has been missing for three days now...", ru:"Хикару! Ты слышал? Глен пропал уже три дня назад...", tr:"Hikaru! Duydun mu? Glen üç gündür kayıp..." },
  dlg_hikaru_r1:    { en:"I know. The police said they couldn't find any traces.", ru:"Я знаю. Полиция сказала, что не нашла никаких следов.", tr:"Biliyorum. Polis hiçbir iz bulamadıklarını söyledi." },
  dlg_rina_2:       { en:"They barely even tried! We have to do something ourselves.", ru:"Они даже толком не пытались! Мы должны сами что-то сделать.", tr:"Neredeyse hiç denemediler bile! Biz kendimiz bir şeyler yapmalıyız." },
  dlg_hikaru_r2:    { en:"You're right. Let's gather the group and investigate.", ru:"Ты права. Давай соберём группу и расследуем.", tr:"Haklısın. Grubu toplayıp araştıralım." },
  // Dialogue — Neighborhood: Kenji
  dlg_kenji_repeat: { en:"I'll check around here some more. You guys go to town.", ru:"Я ещё поищу тут. А вы идите в город.", tr:"Ben buralarda biraz daha bakacağım. Siz şehre gidin." },
  dlg_kenji_1:      { en:"Yo, Hikaru. This is messed up. Glen wouldn't just vanish like that.", ru:"Йо, Хикару. Это ненормально. Глен не мог просто так исчезнуть.", tr:"Hey, Hikaru. Bu çok saçma. Glen öylece ortadan kaybolmazdı." },
  dlg_hikaru_k1:    { en:"Did he say anything to you before he disappeared?", ru:"Он тебе что-нибудь говорил перед тем, как исчез?", tr:"Kaybolmadan önce sana bir şey söyledi mi?" },
  dlg_kenji_2:      { en:"Last thing he told me was he found some 'interesting place' near the old forest...", ru:"Последнее, что он мне сказал — он нашёл какое-то «интересное место» у старого леса...", tr:"Bana söylediği son şey eski ormanın yakınında 'ilginç bir yer' bulduğuydu..." },
  dlg_kenji_3:      { en:"I didn't think much of it then. But now...", ru:"Тогда я не придал этому значения. Но сейчас...", tr:"O zaman pek üzerinde durmadım. Ama şimdi..." },
  dlg_hikaru_k2:    { en:"The old forest? That's worth investigating.", ru:"Старый лес? Стоит это расследовать.", tr:"Eski orman mı? Araştırmaya değer." },
  // Dialogue — Town: Officer
  dlg_officer_repeat: { en:"I already told you, we've done everything we can. Go home, kids.", ru:"Я уже сказал, мы сделали всё, что могли. Идите домой, ребята.", tr:"Size zaten söyledim, elimizden gelen her şeyi yaptık. Eve gidin çocuklar." },
  dlg_hikaru_o1:      { en:"Officer, about our friend Glen who went missing...", ru:"Офицер, насчёт нашего друга Глена, который пропал...", tr:"Memur bey, kaybolan arkadaşımız Glen hakkında..." },
  dlg_officer_1:      { en:"Ah, the Tanaka boy. Look, we searched the area thoroughly.", ru:"А, мальчик Танака. Послушайте, мы тщательно обыскали район.", tr:"Ah, Tanaka çocuğu. Bakın, bölgeyi baştan sona aradık." },
  dlg_officer_2:      { en:"No signs of foul play. He probably just ran away from home. It happens.", ru:"Никаких признаков преступления. Скорее всего, он просто сбежал из дома. Такое бывает.", tr:"Suç belirtisi yok. Muhtemelen evden kaçmıştır. Olur böyle şeyler." },
  dlg_rina_o1:        { en:"That's not like Glen at all! He wouldn't just leave!", ru:"Это совсем не похоже на Глена! Он бы просто так не ушёл!", tr:"Bu Glen'e hiç benzemiyor! Öylece gitmezdi!" },
  dlg_officer_3:      { en:"I understand your concern, but there's nothing more we can do.", ru:"Я понимаю вашу обеспокоенность, но мы больше ничего не можем сделать.", tr:"Endişenizi anlıyorum ama yapabileceğimiz başka bir şey yok." },
  dlg_hikaru_o2:      { en:"(The police are useless... We'll have to find him ourselves.)", ru:"(Полиция бесполезна... Придётся искать его самим.)", tr:"(Polisin hiç faydası yok... Onu kendimiz bulmalıyız.)" },
  // Dialogue — Town: Shopkeeper
  dlg_shop_repeat:    { en:"Please be careful near that forest. Strange things happen there at night.", ru:"Пожалуйста, будьте осторожны рядом с тем лесом. Там по ночам происходят странные вещи.", tr:"Lütfen o ormanın yakınında dikkatli olun. Geceleri orada garip şeyler oluyor." },
  dlg_hikaru_s1:      { en:"Excuse me, have you seen a boy with green hair around here recently?", ru:"Простите, вы не видели тут недавно мальчика с зелёными волосами?", tr:"Affedersiniz, son zamanlarda buralarda yeşil saçlı bir çocuk gördünüz mü?" },
  dlg_shop_1:         { en:"Green hair? Oh my... yes, I think I saw someone like that.", ru:"Зелёные волосы? О боже... да, кажется, я видела кого-то такого.", tr:"Yeşil saçlı mı? Aman... evet, öyle birini gördüm sanırım." },
  dlg_shop_2:         { en:"It was late at night, about three days ago. He was heading toward the old forest path.", ru:"Это было поздно ночью, примерно три дня назад. Он шёл по тропинке к старому лесу.", tr:"Gece geç saatlerdi, yaklaşık üç gün önce. Eski orman yoluna doğru gidiyordu." },
  dlg_hikaru_s2:      { en:"The old forest! That's what Kenji mentioned too!", ru:"Старый лес! Кэндзи тоже об этом говорил!", tr:"Eski orman! Kenji de bundan bahsetmişti!" },
  dlg_shop_3:         { en:"You're not thinking of going there, are you? That place gives me the creeps.", ru:"Вы же не собираетесь туда идти? Это место вселяет в меня жуть.", tr:"Oraya gitmeyi düşünmüyorsunuz, değil mi? Orası beni çok ürpertiyor." },
  dlg_shop_4:         { en:"People say they hear strange sounds coming from deep in those woods...", ru:"Люди говорят, что слышат странные звуки из глубины тех лесов...", tr:"İnsanlar o ormanın derinliklerinden garip sesler duyduklarını söylüyor..." },
  dlg_hikaru_s3:      { en:"We have to find our friend. Thank you for the information!", ru:"Мы должны найти нашего друга. Спасибо за информацию!", tr:"Arkadaşımızı bulmalıyız. Bilgi için teşekkürler!" },
  // Dialogue — Forest: Backpack
  dlg_backpack_repeat:   { en:"Glen's backpack... He was definitely here.", ru:"Рюкзак Глена... Он точно был здесь.", tr:"Glen'in sırt çantası... Kesinlikle buradaymış." },
  dlg_backpack_1:        { en:"You found a backpack on the ground.", ru:"Вы нашли рюкзак на земле.", tr:"Yerde bir sırt çantası buldunuz." },
  dlg_hikaru_b1:         { en:"Wait... this is Glen's backpack!", ru:"Подожди... это рюкзак Глена!", tr:"Dur... bu Glen'in sırt çantası!" },
  dlg_rina_b1:           { en:"Oh no... He was here. But where did he go?", ru:"О нет... Он был здесь. Но куда он делся?", tr:"Hayır... Buradaymış. Ama nereye gitti?" },
  dlg_kenji_b1:          { en:"Look, there's a faint trail leading deeper into the forest...", ru:"Смотрите, здесь слабый след, ведущий глубже в лес...", tr:"Bakın, ormanın derinliklerine doğru giden belirsiz bir iz var..." },
  dlg_hikaru_b2:         { en:"And... do you see that? There's a strange light coming from further in.", ru:"И... вы это видите? Оттуда, из глубины, идёт странный свет.", tr:"Ve... şunu görüyor musunuz? İleriden garip bir ışık geliyor." },
  dlg_rina_b2:           { en:"I don't see anything...", ru:"Я ничего не вижу...", tr:"Ben hiçbir şey görmüyorum..." },
  dlg_hikaru_b3:         { en:"(Am I the only one who can see it? Something feels very wrong...)", ru:"(Неужели только я это вижу? Что-то здесь очень не так...)", tr:"(Bunu sadece ben mi görüyorum? Bir şeyler çok yanlış...)" },
  // Dialogue — Forest: Portal
  dlg_portal_not_ready:  { en:"There's something strange about this area... Let me look around more first.", ru:"В этом месте что-то странное... Давай сначала осмотримся получше.", tr:"Bu bölgede garip bir şey var... Önce biraz daha etrafı araştırayım." },
  dlg_portal_1:          { en:"A swirling void of purple energy pulses before you.", ru:"Перед вами пульсирует вихрь фиолетовой энергии.", tr:"Önünüzde dönen mor bir enerji girdabı atıyor." },
  dlg_hikaru_p1:         { en:"What... what is this?!", ru:"Что... что это?!", tr:"Bu... bu ne?!" },
  dlg_rina_p1:           { en:"Hikaru, what are you staring at? I just see old trees...", ru:"Хикару, на что ты смотришь? Я вижу только старые деревья...", tr:"Hikaru, neye bakıyorsun? Ben sadece eski ağaçlar görüyorum..." },
  dlg_kenji_p1:          { en:"Yeah man, there's nothing there.", ru:"Да, чувак, там ничего нет.", tr:"Evet dostum, orada hiçbir şey yok." },
  dlg_hikaru_p2:         { en:"You can't see it?! There's a massive portal right here!", ru:"Вы не видите?! Тут огромный портал!", tr:"Göremiyorsunuz mu?! Tam burada kocaman bir portal var!" },
  dlg_hikaru_p3:         { en:"Glen must have gone through here. I... I can feel it.", ru:"Глен, должно быть, прошёл сюда. Я... я чувствую это.", tr:"Glen buradan geçmiş olmalı. Ben... hissedebiliyorum." },
  dlg_rina_p2:           { en:"Hikaru, you're scaring me...", ru:"Хикару, ты меня пугаешь...", tr:"Hikaru, beni korkutuyorsun..." },
  dlg_hikaru_p4:         { en:"I'm going in. Glen needs our help.", ru:"Я иду туда. Глену нужна наша помощь.", tr:"Ben giriyorum. Glen'in yardımımıza ihtiyacı var." },
  dlg_kenji_p2:          { en:"If you're going, we're going with you. We're not leaving anyone behind.", ru:"Если ты идёшь, мы идём с тобой. Мы никого не бросим.", tr:"Sen gidiyorsan, biz de seninle geliyoruz. Kimseyi geride bırakmayız." },
  dlg_portal_2:          { en:"The three of you step forward into the unknown...", ru:"Вы втроём шагаете в неизвестность...", tr:"Üçünüz birlikte bilinmeze doğru adım atıyorsunuz..." },

  // ── ACT 2 & 3 STRINGS ──
  // Character names
  name_larry:    { en:'Larry', ru:'Ларри', tr:'Larry' },
  name_glen_boss:{ en:'Glen', ru:'Глен', tr:'Glen' },
  // Act titles
  title_subtitle_act2: { en:'Act 2: The Beautiful Trap', ru:'Акт 2: Прекрасная ловушка', tr:'Perde 2: Güzel Tuzak' },
  title_subtitle_act3: { en:'Act 3: Whispers in the Dark', ru:'Акт 3: Шёпот во тьме', tr:'Perde 3: Karanlıktaki Fısıltılar' },
  // Act 2 objectives
  obj_explore_underdark: { en:'Explore this strange new world', ru:'Исследуй этот странный новый мир', tr:'Bu garip yeni dünyayı keşfet' },
  obj_find_glen:         { en:'Find Glen deeper in the Underdark', ru:'Найди Глена в глубинах Андердарка', tr:"Glen'i Underdark'ın derinliklerinde bul" },
  obj_confront_glen:     { en:'Confront Glen', ru:'Противостой Глену', tr:'Glen ile yüzleş' },
  obj_defeat_glen:       { en:"Survive Glen's attack — get close to him!", ru:'Переживи атаку Глена — подберись к нему!', tr:"Glen'in saldırısından kurtul — ona yaklaş!" },
  // Act 3 objectives
  obj_follow_friends:       { en:'Follow your friends deeper', ru:'Следуй за друзьями глубже', tr:'Arkadaşlarını daha derine takip et' },
  obj_investigate_whispers: { en:'Investigate the whispers', ru:'Расследуй шёпот', tr:'Fısıltıları araştır' },
  obj_find_larry:           { en:'Approach the figure in the bushes', ru:'Подойди к фигуре в кустах', tr:'Çalılıklardaki figüre yaklaş' },
  obj_survive_larry:        { en:"Survive! It's not Larry!", ru:'Выживи! Это не Ларри!', tr:'Hayatta kal! Bu Larry değil!' },
  // Act 2 endings
  end2_sacrifice: { en:"Glen's light fades...", ru:'Свет Глена угасает...', tr:"Glen'in ışığı sönüyor..." },
  end2_line1:     { en:'He chose to save the ones he loved', ru:'Он выбрал спасти тех, кого любил', tr:'Sevdiklerini kurtarmayı seçti' },
  end2_line2:     { en:'even if it meant losing himself.', ru:'даже если это означало потерять себя.', tr:'kendini kaybetmek anlamına gelse bile.' },
  end2_act:       { en:'End of Act 2', ru:'Конец 2 Акта', tr:'2. Perde Sonu' },
  end2_cont:      { en:'The darkness deepens...', ru:'Тьма сгущается...', tr:'Karanlık derinleşiyor...' },
  // Act 3 endings
  end3_reveal: { en:'The truth was never what it seemed...', ru:'Правда никогда не была такой, какой казалась...', tr:'Gerçek hiçbir zaman göründüğü gibi değildi...' },
  end3_line1:  { en:'Hikaru alone sees through the lies', ru:'Только Хикару видит сквозь ложь', tr:'Sadece Hikaru yalanları görebiliyor' },
  end3_line2:  { en:'but his friends have already fallen.', ru:'но его друзья уже пали.', tr:'ama arkadaşları çoktan düşmüş.' },
  end3_act:    { en:'End of Act 3', ru:'Конец 3 Акта', tr:'3. Perde Sonu' },
  end3_cont:   { en:'To be continued in Act 4...', ru:'Продолжение в Акте 4...', tr:'4. Perdede devam edecek...' },
  // Tap to continue
  ui_tap_continue: { en:'Tap to continue', ru:'Нажми, чтобы продолжить', tr:'Devam etmek için dokun' },
  // Act 2 — Underdark entrance
  dlg_arrive_1:       { en:'You emerge into a world of breathtaking beauty.', ru:'Вы выходите в мир захватывающей красоты.', tr:'Nefes kesen güzellikte bir dünyaya çıkıyorsunuz.' },
  dlg_rina_arrive1:   { en:'Wow... this place is incredible! Look at these crystals!', ru:'Ого... это место невероятное! Посмотри на эти кристаллы!', tr:'Vay... burası inanılmaz! Şu kristallere bak!' },
  dlg_kenji_arrive1:  { en:"Is this where Glen went? It doesn't seem dangerous at all...", ru:'Сюда ушёл Глен? Совсем не кажется опасным...', tr:'Glen buraya mı gelmiş? Hiç tehlikeli görünmüyor...' },
  dlg_hikaru_arrive1: { en:'(Wait... I see something they don\'t. Dark shapes behind the beauty... What is this place?)', ru:'(Подожди... Я вижу то, что они не видят. Тёмные формы за красотой... Что это за место?)', tr:'(Dur... Onların görmediği bir şey görüyorum. Güzelliğin arkasındaki karanlık şekiller... Burası ne?)' },
  dlg_hikaru_arrive2: { en:"Let's keep moving. Glen has to be here somewhere.", ru:'Давайте продолжим. Глен должен быть где-то здесь.', tr:'İlerlemeye devam edelim. Glen burada bir yerde olmalı.' },
  // Dark sign
  dlg_dark_sign_1:    { en:'You notice strange dark marks on the ground.', ru:'Вы замечаете странные тёмные следы на земле.', tr:'Yerde garip karanlık izler fark ediyorsunuz.' },
  dlg_hikaru_sign1:   { en:'(These marks... veins of darkness running through the ground. The others can\'t see them.)', ru:'(Эти следы... вены тьмы, проходящие сквозь землю. Остальные их не видят.)', tr:'(Bu izler... yerden geçen karanlık damarlar. Diğerleri onları göremiyorlar.)' },
  dlg_hikaru_sign2:   { en:'(This beautiful world is hiding something. I can feel it.)', ru:'(Этот красивый мир что-то скрывает. Я чувствую это.)', tr:'(Bu güzel dünya bir şey saklıyor. Hissedebiliyorum.)' },
  // Crystal fairy
  dlg_fairy_1:        { en:'Welcome, travelers... You have been chosen by the Underdark.', ru:'Добро пожаловать, путники... Вы были избраны Андердарком.', tr:'Hoş geldiniz, yolcular... Underdark tarafından seçildiniz.' },
  dlg_fairy_2:        { en:'Stay as long as you wish. This is a place of peace and beauty.', ru:'Оставайтесь сколько хотите. Это место мира и красоты.', tr:'İstediğiniz kadar kalın. Burası huzur ve güzellik yeri.' },
  dlg_hikaru_fairy1:  { en:'(Peace? Then why do I see shadows crawling beneath the crystal?)', ru:'(Мир? Тогда почему я вижу тени, ползающие под кристаллами?)', tr:'(Huzur mu? O zaman neden kristallerin altında sürünen gölgeler görüyorum?)' },
  dlg_rina_fairy1:    { en:'Have you seen a boy with green hair? Our friend Glen?', ru:'Вы видели мальчика с зелёными волосами? Наш друг Глен?', tr:'Yeşil saçlı bir çocuk gördünüz mü? Arkadaşımız Glen?' },
  dlg_fairy_3:        { en:'Your friend... yes, he went deeper. He was drawn to the heart of this place.', ru:'Ваш друг... да, он ушёл глубже. Его притянуло к сердцу этого места.', tr:'Arkadaşınız... evet, daha derine gitti. Bu yerin kalbine çekildi.' },
  dlg_fairy_repeat:   { en:'The deeper paths await you... if you dare.', ru:'Более глубокие пути ждут вас... если осмелитесь.', tr:'Daha derin yollar sizi bekliyor... cesaret ederseniz.' },
  // Act 2 — Glen boss encounter
  dlg_glen_found_1:   { en:'You see a figure standing in the center of a dark crystal arena.', ru:'Вы видите фигуру в центре тёмной кристальной арены.', tr:'Karanlık kristal arenanın ortasında duran bir figür görüyorsunuz.' },
  dlg_glen_found_2:   { en:"It's Glen... but something is terribly wrong.", ru:'Это Глен... но что-то ужасно не так.', tr:'Bu Glen... ama bir şeyler çok yanlış.' },
  dlg_rina_glen1:     { en:"Glen! We finally found you! Come on, let's go home!", ru:'Глен! Мы наконец-то нашли тебя! Пошли домой!', tr:'Glen! Sonunda seni bulduk! Hadi, eve gidelim!' },
  dlg_glen_boss_1:    { en:'Home...? There is no home. The Underdark IS home now.', ru:'Домой...? Дома нет. Андердарк — теперь дом.', tr:'Eve mi...? Ev yok. Underdark artık EVİMİZ.' },
  dlg_glen_boss_2:    { en:"You shouldn't have come here. Now you'll stay too... FOREVER.", ru:'Вам не стоило сюда приходить. Теперь останетесь... НАВСЕГДА.', tr:'Buraya gelmemeliydiniz. Artık siz de kalacaksınız... SONSUZA KADAR.' },
  dlg_kenji_glen1:    { en:"Glen, snap out of it! This isn't you!", ru:'Глен, очнись! Это не ты!', tr:'Glen, kendine gel! Bu sen değilsin!' },
  dlg_hikaru_glen1:   { en:"He's being controlled... We have to get through to him!", ru:'Его контролируют... Мы должны до него достучаться!', tr:'Kontrol ediliyor... Ona ulaşmalıyız!' },
  // Boss approach dialogues
  dlg_boss_approach_1: { en:"Glen... remember us! We're your friends!", ru:'Глен... вспомни нас! Мы твои друзья!', tr:'Glen... bizi hatırla! Biz senin arkadaşlarınız!' },
  dlg_glen_fight_1:    { en:'F-friends...? No... GET AWAY!', ru:'Д-друзья...? Нет... УХОДИТЕ!', tr:'A-arkadaşlar...? Hayır... UZAKLAŞIN!' },
  dlg_boss_approach_2: { en:"Fight it, Glen! You're stronger than this darkness!", ru:'Борись, Глен! Ты сильнее этой тьмы!', tr:'Savaş Glen! Bu karanlıktan daha güçlüsün!' },
  dlg_glen_fight_2:    { en:'I... I can hear you... but it hurts... it hurts so much...', ru:'Я... я слышу вас... но больно... так больно...', tr:'Ben... sizi duyabiliyorum... ama acıyor... çok acıyor...' },
  dlg_boss_approach_3: { en:"We're not leaving without you, Glen. We never leave anyone behind!", ru:'Мы не уйдём без тебя, Глен. Мы никого не бросаем!', tr:'Sensiz gitmiyoruz Glen. Kimseyi geride bırakmayız!' },
  dlg_glen_fight_3:    { en:"You... you have to go. I can feel it taking over...", ru:'Вы... вам нужно уйти. Я чувствую, как оно захватывает...', tr:'Siz... gitmelisiniz. Ele geçirdiğini hissedebiliyorum...' },
  // Glen sacrifice
  dlg_glen_sacrifice_1: { en:'Glen suddenly stops. His eyes clear for just a moment.', ru:'Глен внезапно останавливается. Его глаза проясняются на мгновение.', tr:'Glen aniden duruyor. Gözleri sadece bir anlığına açılıyor.' },
  dlg_glen_sacrifice_2: { en:'I remember now... I remember everything.', ru:'Я помню теперь... Я помню всё.', tr:'Şimdi hatırlıyorum... Her şeyi hatırlıyorum.' },
  dlg_glen_sacrifice_3: { en:'This place... it feeds on us. It trapped me, and now it wants all of you.', ru:'Это место... питается нами. Оно поймало меня, а теперь хочет всех вас.', tr:'Bu yer... bizden besleniyor. Beni tuzağa düşürdü, şimdi hepinizi istiyor.' },
  dlg_glen_sacrifice_4: { en:"But I won't let it. Not you guys. Not my friends.", ru:'Но я этого не допущу. Не вас. Не моих друзей.', tr:'Ama izin vermeyeceğim. Sizi değil. Arkadaşlarımı değil.' },
  dlg_rina_sacrifice:   { en:'Glen, no! What are you doing?!', ru:'Глен, нет! Что ты делаешь?!', tr:'Glen, hayır! Ne yapıyorsun?!' },
  dlg_glen_sacrifice_5: { en:"Getting you out of here. Tell my family... I'm sorry.", ru:'Выпускаю вас отсюда. Скажите моей семье... простите.', tr:'Sizi buradan çıkarıyorum. Aileme söyleyin... özür dilerim.' },
  dlg_glen_sacrifice_6: { en:'A blinding light engulfs everything. You feel yourselves being pulled away...', ru:'Ослепляющий свет поглощает всё. Вы чувствуете, как вас уносит...', tr:'Kör edici bir ışık her şeyi yutuyor. Kendinizi uzaklaşırken hissediyorsunuz...' },
  // Act 3 — Waking up
  dlg_act3_wake_1:    { en:'You find yourselves in a darker part of the Underdark.', ru:'Вы оказываетесь в более тёмной части Андердарка.', tr:"Kendinizi Underdark'ın daha karanlık bir bölümünde buluyorsunuz." },
  dlg_act3_wake_2:    { en:"Glen's sacrifice didn't send you home... it sent you deeper.", ru:'Жертва Глена не отправила вас домой... она отправила вас глубже.', tr:"Glen'in fedakarlığı sizi eve göndermedi... daha derine gönderdi." },
  dlg_hikaru_wake1:   { en:"Glen... he's gone. And we're still trapped here.", ru:'Глен... его нет. И мы всё ещё в ловушке.', tr:'Glen... gitti. Ve biz hala burada tuzaktayız.' },
  dlg_rina_wake1:     { en:'This place is so beautiful though... maybe we should just... stay a while?', ru:'Но это место такое красивое... может, просто... останемся ненадолго?', tr:'Ama burası çok güzel... belki sadece... biraz kalmalıyız?' },
  dlg_hikaru_wake2:   { en:"(Beautiful? This place is rotting. Can't they see the corruption everywhere?)", ru:'(Красиво? Это место гниёт. Они не видят повсюду порчу?)', tr:'(Güzel mi? Burası çürüyor. Her yerdeki bozulmayı göremiyorlar mı?)' },
  dlg_kenji_wake1:    { en:'Chill out, Hikaru. We just need to rest. My head feels... fuzzy.', ru:'Расслабься, Хикару. Нам просто нужно отдохнуть. В голове туман.', tr:'Sakin ol Hikaru. Sadece dinlenmeliyiz. Kafam... bulanık.' },
  // Warning dialogue
  dlg_hikaru_warn1:   { en:"Guys, listen to me. This world is not what it looks like. It's a trap!", ru:'Ребята, послушайте. Этот мир не то, чем кажется. Это ловушка!', tr:'Dinleyin beni. Bu dünya göründüğü gibi değil. Bu bir tuzak!' },
  dlg_rina_dismiss1:  { en:'Hikaru, you\'re overreacting. Everything is fine. Just relax.', ru:'Хикару, ты преувеличиваешь. Всё хорошо. Расслабься.', tr:'Hikaru, abartıyorsun. Her şey yolunda. Sadece rahatla.' },
  dlg_kenji_dismiss1: { en:"Yeah, man. You've been saying weird stuff since we got here. Take it easy.", ru:'Да, чувак. Ты говоришь странные вещи с тех пор, как мы тут. Успокойся.', tr:'Evet dostum. Buraya geldiğimizden beri garip şeyler söylüyorsun. Sakin ol.' },
  dlg_hikaru_warn2:   { en:"(They're not listening... the Underdark is already getting to them.)", ru:'(Они не слушают... Андердарк уже добирается до них.)', tr:'(Dinlemiyorlar... Underdark onları çoktan etkiliyor.)' },
  // Whispers
  dlg_whisper_1:      { en:'(You hear a faint voice... Glen\'s voice.) "Hikaru... don\'t trust..."', ru:'(Слабый голос... голос Глена.) "Хикару... не верь..."', tr:'(Zayıf bir ses... Glen\'in sesi.) "Hikaru... güvenme..."' },
  dlg_whisper_2:      { en:'(The whisper fades before you can make sense of it.)', ru:'(Шёпот стихает, прежде чем вы успеваете понять.)', tr:'(Fısıltı anlamlandıramadan kayboluyor.)' },
  dlg_whisper_3:      { en:'(Glen\'s voice again, clearer.) "...not real... none of it..."', ru:'(Снова голос Глена, чётче.) "...не реально... ничего из этого..."', tr:'(Glen\'in sesi tekrar, daha net.) "...gerçek değil... hiçbiri..."' },
  // Larry encounter
  dlg_larry_spot_1:   { en:'Wait... is that someone in the bushes?', ru:'Подождите... это кто-то в кустах?', tr:'Durun... çalılıklarda biri mi var?' },
  dlg_rina_larry1:    { en:'It looks like... a person! Hey, over here!', ru:'Похоже на... человека! Эй, сюда!', tr:'Bir insana benziyor! Hey, buraya!' },
  dlg_hikaru_larry1:  { en:'(Something feels wrong. I see it differently than they do...)', ru:'(Что-то не так. Я вижу это не так, как они...)', tr:'(Bir şeyler yanlış. Onu onlardan farklı görüyorum...)' },
  dlg_larry_1:        { en:"H-hello? Can you help me? I've been lost in here for days...", ru:'П-привет? Вы можете помочь? Я заблудился тут на несколько дней...', tr:'M-merhaba? Bana yardım edebilir misiniz? Günlerdir burada kayıp...' },
  dlg_kenji_larry1:   { en:"Don't worry, we'll figure this out together. What's your name?", ru:'Не волнуйся, мы разберёмся вместе. Как тебя зовут?', tr:'Merak etme, bunu birlikte çözeriz. Adın ne?' },
  dlg_larry_2:        { en:"I'm Larry. I came here through a strange light, just like you.", ru:'Я Ларри. Я попал сюда через странный свет, как и вы.', tr:'Ben Larry. Buraya garip bir ışıktan geçerek geldim, sizin gibi.' },
  dlg_hikaru_larry2:  { en:"(Wait. His eyes... they're not right. This isn't a real person.)", ru:'(Подождите. Его глаза... что-то не так. Это не настоящий человек.)', tr:"(Dur. Gözleri... doğru değil. Bu gerçek bir insan değil.)" },
  dlg_hikaru_larry3:  { en:"Everyone, get back! That's not a person — it's a trap!", ru:'Все, назад! Это не человек — это ловушка!', tr:'Herkes geri çekilin! Bu bir insan değil — bu bir tuzak!' },
  dlg_rina_larry2:    { en:"Hikaru, what are you talking about? He's clearly just scared!", ru:'Хикару, о чём ты? Он просто напуган!', tr:'Hikaru, neden bahsediyorsun? Belli ki sadece korkmuş!' },
  dlg_kenji_larry2:   { en:'Stop being paranoid, man. Not everything here is out to get us.', ru:'Перестань параноить. Не всё здесь хочет нас достать.', tr:'Paranoyak olmayı bırak. Burada her şey bize saldırmıyor.' },
  dlg_larry_reveal_1: { en:"Larry's face suddenly distorts into a grotesque grin.", ru:'Лицо Ларри искажается в гротескной ухмылке.', tr:"Larry'nin yüzü aniden grotesk bir sırıtışa dönüşüyor." },
  dlg_larry_reveal_2: { en:"How clever... you can see through it, can't you, little one?", ru:'Как умно... ты видишь сквозь это, не так ли, малыш?', tr:'Ne kadar zeki... görebiliyorsun, değil mi, küçük olan?' },
  dlg_larry_reveal_3: { en:"But your friends can't. And they're already MINE.", ru:'Но твои друзья — нет. И они уже МОИ.', tr:'Ama arkadaşların göremiyor. Ve onlar zaten BENİM.' },
  dlg_rina_fight1:    { en:'What\'s happening?! Larry, what are you — AAAH!', ru:'Что происходит?! Ларри, ты что — АААА!', tr:'Ne oluyor?! Larry, sen ne — AAAH!' },
  dlg_kenji_fight1:   { en:"It's attacking! Watch out!", ru:'Оно атакует! Берегитесь!', tr:'Saldırıyor! Dikkat edin!' },
  dlg_hikaru_fight1:  { en:'I tried to warn you! We have to fight it!', ru:'Я пытался предупредить! Мы должны сражаться!', tr:'Uyarmaya çalıştım! Onunla savaşmalıyız!' },
  // After clone fight
  dlg_clone_defeat_1: { en:'The creature dissolves into dark mist, but the damage is done.', ru:'Существо растворяется в тумане, но ущерб нанесён.', tr:'Yaratık karanlık sise dönüşüyor ama hasar verilmiş.' },
  dlg_rina_after1:    { en:'I... I feel strange. Hikaru, you were right... something IS wrong here.', ru:'Мне... странно. Хикару, ты был прав... здесь что-то НЕ ТАК.', tr:'Ben... garip hissediyorum. Hikaru, haklıymışsın... burada bir şeyler YANLIŞ.' },
  dlg_kenji_after1:   { en:"My head... I can't think straight. What was I just doing?", ru:'Моя голова... Не могу ясно думать. Что я делал?', tr:'Kafam... düzgün düşünemiyorum. Az önce ne yapıyordum?' },
  dlg_hikaru_after1:  { en:'The Underdark has been possessing you. We need to get out. NOW.', ru:'Андердарк вас одержимает. Нам нужно выбраться. СЕЙЧАС.', tr:'Underdark sizi ele geçiriyordu. Çıkmamız lazım. HEMEN.' },
  dlg_hikaru_after2:  { en:'(Glen\'s whisper: "Find the heart... destroy the heart...")', ru:'(Шёпот Глена: "Найди сердце... уничтожь сердце...")', tr:'(Glen\'in fısıltısı: "Kalbi bul... kalbi yok et...")' },
  dlg_end3_narration: { en:"The ground shakes. The Underdark knows you're awake now.", ru:'Земля дрожит. Андердарк знает, что вы очнулись.', tr:'Yer sarsılıyor. Underdark uyanık olduğunuzu biliyor.' },
};
function t(key) { return STRINGS[key][lang]; }

// ── GAME STATE ──
let gameState = 'title'; // title, playing, dialogue, transition, fadein, ending, boss
let storyFlags = {};
let currentMap = 'neighborhood';
let currentAct = 1;
let objective = '';
let transitionAlpha = 0;
let transitionTarget = null;
let transitionSpawn = null;
let endingTimer = 0;
let bossState = null;
let possessionLevel = 0;
let returnToBoss = false;

// ── PLAYER ──
let player = { x: 5*TILE, y: 8*TILE, dir: 0, frame: 0, animTimer: 0, moving: false, char: CHARS.hikaru };

// ── FOLLOWERS ──
let followers = [
  { id:'rina', char: CHARS.rina, x: 0, y: 0, dir: 0, frame: 0, animTimer: 0, moving: false, active: false },
  { id:'kenji', char: CHARS.kenji, x: 0, y: 0, dir: 0, frame: 0, animTimer: 0, moving: false, active: false },
];
let trail = [];
const TRAIL_SPACING = 28;

// ── CAMERA ──
let cam = { x: 0, y: 0 };

// ── INPUT ──
let joystick = { active: false, id: null, sx: 0, sy: 0, cx: 0, cy: 0, dx: 0, dy: 0 };
let actionBtn = { active: false, pressed: false, id: null };
let tapAction = false;

function hitLangButton(px, py) {
  const btnW = 44, btnH = 28, gap = 8;
  const totalW = btnW * 3 + gap * 2;
  const lx = W/2 - totalW/2, ly = 14;
  const langs = ['tr', 'en', 'ru'];
  for (let i = 0; i < 3; i++) {
    const bx = lx + i * (btnW + gap);
    if (px >= bx && px <= bx + btnW && py >= ly && py <= ly + btnH) {
      lang = langs[i];
      localStorage.setItem('underdark-lang', lang);
      objective = t('obj_talk_friends');
      return true;
    }
  }
  return false;
}

function handleTouchStart(e) {
  e.preventDefault();
  for (let t of e.changedTouches) {
    const x = t.clientX, y = t.clientY;
    if (gameState === 'title') {
      if (hitLangButton(x, y)) return;
      gameState = 'playing'; return;
    }
    if (gameState === 'ending') {
      if (endingTimer >= 8000 && currentAct < 3) { tapAction = true; }
      return;
    }
    if (gameState === 'dialogue') { tapAction = true; return; }
    if (x < W * 0.5) {
      if (!joystick.active) {
        joystick.active = true; joystick.id = t.identifier;
        joystick.sx = x; joystick.sy = y; joystick.cx = x; joystick.cy = y;
      }
    } else {
      actionBtn.active = true; actionBtn.pressed = true; actionBtn.id = t.identifier;
    }
  }
}
function handleTouchMove(e) {
  e.preventDefault();
  for (let t of e.changedTouches) {
    if (t.identifier === joystick.id) {
      joystick.cx = t.clientX; joystick.cy = t.clientY;
      let dx = joystick.cx - joystick.sx, dy = joystick.cy - joystick.sy;
      let dist = Math.sqrt(dx*dx + dy*dy);
      let maxR = 50;
      if (dist > maxR) { dx = dx/dist*maxR; dy = dy/dist*maxR; }
      joystick.dx = dx / maxR; joystick.dy = dy / maxR;
    }
  }
}
function handleTouchEnd(e) {
  e.preventDefault();
  for (let t of e.changedTouches) {
    if (t.identifier === joystick.id) {
      joystick.active = false; joystick.id = null;
      joystick.dx = 0; joystick.dy = 0;
    }
    if (t.identifier === actionBtn.id) {
      actionBtn.active = false; actionBtn.id = null;
    }
  }
}
canvas.addEventListener('touchstart', handleTouchStart, {passive:false});
canvas.addEventListener('touchmove', handleTouchMove, {passive:false});
canvas.addEventListener('touchend', handleTouchEnd, {passive:false});
canvas.addEventListener('touchcancel', handleTouchEnd, {passive:false});

// Mouse click (for language buttons and desktop title start)
canvas.addEventListener('click', e => {
  if (gameState === 'title') {
    if (hitLangButton(e.clientX, e.clientY)) return;
    gameState = 'playing';
  }
});

// Keyboard fallback
let keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (gameState === 'title' && (e.key === ' ' || e.key === 'Enter')) gameState = 'playing';
  if (gameState === 'dialogue' && (e.key === ' ' || e.key === 'Enter')) tapAction = true;
  if (gameState === 'ending' && endingTimer >= 8000 && currentAct < 3 && (e.key === ' ' || e.key === 'Enter')) tapAction = true;
  if (e.key === ' ' || e.key === 'e' || e.key === 'Enter') actionBtn.pressed = true;
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

// ── TILE TYPES ──
const T = {
  GRASS: 0, PATH: 1, WALL: 2, ROOF: 3, DOOR: 4, WATER: 5,
  TREE: 6, ROCK: 7, FENCE: 8, DARK_GRASS: 9, DEAD_TREE: 10,
  PORTAL: 11, FLOOR: 12, WINDOW_WALL: 13, BUSH: 14,
  FLOWER: 15, BRIDGE: 16, SIGN: 17, LAMP: 18,
  CRYSTAL_GRASS: 19, CRYSTAL: 20, DARK_FLOOR: 21, CORRUPT_TREE: 22, VOID: 23
};
const WALKABLE = new Set([T.GRASS, T.PATH, T.DOOR, T.DARK_GRASS, T.PORTAL, T.FLOOR, T.BRIDGE, T.FLOWER, T.CRYSTAL_GRASS, T.DARK_FLOOR]);

// ── MAPS ──
const MAPS = {};

MAPS.neighborhood = {
  w: 30, h: 22,
  tiles: buildMap_neighborhood(),
  npcs: [
    { id:'rina', x:12*TILE, y:10*TILE, char:CHARS.rina, dir:0,
      dialogue: () => {
        if (storyFlags.talkedRina) return [
          {who:'rina', text:t('dlg_rina_repeat')},
        ];
        storyFlags.talkedRina = true;
        followers[0].active = true;
        followers[0].x = 12*TILE;
        followers[0].y = 10*TILE;
        // Seed trail so follower doesn't teleport
        for (let i = 0; i < TRAIL_SPACING * followers.length + 10; i++) trail.push({x: player.x, y: player.y});
        checkAllTalked();
        return [
          {who:'rina', text:t('dlg_rina_1')},
          {who:'hikaru', text:t('dlg_hikaru_r1')},
          {who:'rina', text:t('dlg_rina_2')},
          {who:'hikaru', text:t('dlg_hikaru_r2')},
        ];
      }
    },
    { id:'kenji', x:18*TILE, y:7*TILE, char:CHARS.kenji, dir:2,
      dialogue: () => {
        if (storyFlags.talkedKenji) return [
          {who:'kenji', text:t('dlg_kenji_repeat')},
        ];
        storyFlags.talkedKenji = true;
        followers[1].active = true;
        followers[1].x = 18*TILE;
        followers[1].y = 7*TILE;
        // Seed trail so follower doesn't teleport
        for (let i = 0; i < TRAIL_SPACING * followers.length + 10; i++) trail.push({x: player.x, y: player.y});
        checkAllTalked();
        return [
          {who:'kenji', text:t('dlg_kenji_1')},
          {who:'hikaru', text:t('dlg_hikaru_k1')},
          {who:'kenji', text:t('dlg_kenji_2')},
          {who:'kenji', text:t('dlg_kenji_3')},
          {who:'hikaru', text:t('dlg_hikaru_k2')},
        ];
      }
    },
  ],
  exits: [
    { x:29, y:10, targetMap:'town', spawnX:1*TILE, spawnY:10*TILE, condition: () => storyFlags.canGoTown },
    { x:29, y:11, targetMap:'town', spawnX:1*TILE, spawnY:11*TILE, condition: () => storyFlags.canGoTown },
  ],
  particles: 'sakura',
};

MAPS.town = {
  w: 32, h: 20,
  tiles: buildMap_town(),
  npcs: [
    { id:'officer', x:22*TILE, y:6*TILE, char:CHARS.officer, dir:2,
      dialogue: () => {
        if (storyFlags.talkedOfficer) return [
          {who:'officer', text:t('dlg_officer_repeat')},
        ];
        storyFlags.talkedOfficer = true;
        checkTownDone();
        return [
          {who:'hikaru', text:t('dlg_hikaru_o1')},
          {who:'officer', text:t('dlg_officer_1')},
          {who:'officer', text:t('dlg_officer_2')},
          {who:'rina', text:t('dlg_rina_o1')},
          {who:'officer', text:t('dlg_officer_3')},
          {who:'hikaru', text:t('dlg_hikaru_o2')},
        ];
      }
    },
    { id:'shopkeeper', x:10*TILE, y:12*TILE, char:CHARS.shopkeeper, dir:0,
      dialogue: () => {
        if (storyFlags.talkedShop) return [
          {who:'shopkeeper', text:t('dlg_shop_repeat')},
        ];
        storyFlags.talkedShop = true;
        checkTownDone();
        return [
          {who:'hikaru', text:t('dlg_hikaru_s1')},
          {who:'shopkeeper', text:t('dlg_shop_1')},
          {who:'shopkeeper', text:t('dlg_shop_2')},
          {who:'hikaru', text:t('dlg_hikaru_s2')},
          {who:'shopkeeper', text:t('dlg_shop_3')},
          {who:'shopkeeper', text:t('dlg_shop_4')},
          {who:'hikaru', text:t('dlg_hikaru_s3')},
        ];
      }
    },
  ],
  exits: [
    { x:0, y:10, targetMap:'neighborhood', spawnX:28*TILE, spawnY:10*TILE },
    { x:0, y:11, targetMap:'neighborhood', spawnX:28*TILE, spawnY:11*TILE },
    { x:31, y:9, targetMap:'forest', spawnX:1*TILE, spawnY:10*TILE, condition: () => storyFlags.canGoForest },
    { x:31, y:10, targetMap:'forest', spawnX:1*TILE, spawnY:11*TILE, condition: () => storyFlags.canGoForest },
  ],
  particles: null,
};

MAPS.forest = {
  w: 35, h: 24,
  tiles: buildMap_forest(),
  npcs: [
    { id:'backpack', x:20*TILE, y:12*TILE, char:null, isObject:true, sprite:'backpack',
      dialogue: () => {
        if (storyFlags.foundBackpack) return [
          {who:null, text:t('dlg_backpack_repeat')},
        ];
        storyFlags.foundBackpack = true;
        objective = t('obj_find_light');
        return [
          {who:null, text:t('dlg_backpack_1')},
          {who:'hikaru', text:t('dlg_hikaru_b1')},
          {who:'rina', text:t('dlg_rina_b1')},
          {who:'kenji', text:t('dlg_kenji_b1')},
          {who:'hikaru', text:t('dlg_hikaru_b2')},
          {who:'rina', text:t('dlg_rina_b2')},
          {who:'hikaru', text:t('dlg_hikaru_b3')},
        ];
      }
    },
    { id:'portal', x:30*TILE, y:5*TILE, char:null, isObject:true, sprite:'portal',
      dialogue: () => {
        if (!storyFlags.foundBackpack) return [
          {who:'hikaru', text:t('dlg_portal_not_ready')},
        ];
        storyFlags.reachedPortal = true;
        return [
          {who:null, text:t('dlg_portal_1')},
          {who:'hikaru', text:t('dlg_hikaru_p1')},
          {who:'rina', text:t('dlg_rina_p1')},
          {who:'kenji', text:t('dlg_kenji_p1')},
          {who:'hikaru', text:t('dlg_hikaru_p2')},
          {who:'hikaru', text:t('dlg_hikaru_p3')},
          {who:'rina', text:t('dlg_rina_p2')},
          {who:'hikaru', text:t('dlg_hikaru_p4')},
          {who:'kenji', text:t('dlg_kenji_p2')},
          {who:null, text:t('dlg_portal_2')},
          {who:null, text:"__ENDING__"},
        ];
      }
    },
  ],
  exits: [
    { x:0, y:10, targetMap:'town', spawnX:30*TILE, spawnY:9*TILE },
    { x:0, y:11, targetMap:'town', spawnX:30*TILE, spawnY:10*TILE },
  ],
  particles: 'fog',
  darkness: 0.3,
};

// ── ACT 2 MAPS ──
MAPS.underdark_entrance = {
  w: 30, h: 20,
  tiles: buildMap_underdark_entrance(),
  npcs: [
    { id:'arrive_trigger', x:15*TILE, y:17*TILE, char:null, isObject:true, sprite:'dark_sign',
      dialogue: () => {
        if (storyFlags.arrivedUnderdark) return null;
        storyFlags.arrivedUnderdark = true;
        return [
          {who:null, text:t('dlg_arrive_1')},
          {who:'rina', text:t('dlg_rina_arrive1')},
          {who:'kenji', text:t('dlg_kenji_arrive1')},
          {who:'hikaru', text:t('dlg_hikaru_arrive1')},
          {who:'hikaru', text:t('dlg_hikaru_arrive2')},
        ];
      }
    },
    { id:'dark_sign', x:20*TILE, y:10*TILE, char:null, isObject:true, sprite:'dark_sign',
      dialogue: () => {
        if (storyFlags.foundDarkSign) return [{who:'hikaru', text:t('dlg_hikaru_sign2')}];
        storyFlags.foundDarkSign = true;
        checkCanGoDepths();
        return [
          {who:null, text:t('dlg_dark_sign_1')},
          {who:'hikaru', text:t('dlg_hikaru_sign1')},
          {who:'hikaru', text:t('dlg_hikaru_sign2')},
        ];
      }
    },
    { id:'fairy', x:10*TILE, y:8*TILE, char:CHARS.fairy, dir:0,
      dialogue: () => {
        if (storyFlags.talkedFairy) return [{who:'fairy', text:t('dlg_fairy_repeat')}];
        storyFlags.talkedFairy = true;
        checkCanGoDepths();
        return [
          {who:'fairy', text:t('dlg_fairy_1')},
          {who:'fairy', text:t('dlg_fairy_2')},
          {who:'hikaru', text:t('dlg_hikaru_fairy1')},
          {who:'rina', text:t('dlg_rina_fairy1')},
          {who:'fairy', text:t('dlg_fairy_3')},
        ];
      }
    },
  ],
  exits: [
    { x:29, y:9, targetMap:'underdark_depths', spawnX:1*TILE, spawnY:10*TILE, condition: () => storyFlags.canGoDepths },
    { x:29, y:10, targetMap:'underdark_depths', spawnX:1*TILE, spawnY:11*TILE, condition: () => storyFlags.canGoDepths },
  ],
  particles: 'sparkle',
};

MAPS.underdark_depths = {
  w: 32, h: 22,
  tiles: buildMap_underdark_depths(),
  npcs: [
    { id:'glen_boss', x:25*TILE, y:11*TILE, char:CHARS.glen_boss, dir:2,
      dialogue: () => {
        if (storyFlags.bossDefeated) return null;
        if (storyFlags.foundGlenBoss) return null;
        storyFlags.foundGlenBoss = true;
        objective = t('obj_defeat_glen');
        return [
          {who:null, text:t('dlg_glen_found_1')},
          {who:null, text:t('dlg_glen_found_2')},
          {who:'rina', text:t('dlg_rina_glen1')},
          {who:'glen_boss', text:t('dlg_glen_boss_1')},
          {who:'glen_boss', text:t('dlg_glen_boss_2')},
          {who:'kenji', text:t('dlg_kenji_glen1')},
          {who:'hikaru', text:t('dlg_hikaru_glen1')},
          {who:null, text:'__BOSS_START__'},
        ];
      }
    },
  ],
  exits: [
    { x:0, y:10, targetMap:'underdark_entrance', spawnX:28*TILE, spawnY:9*TILE },
    { x:0, y:11, targetMap:'underdark_entrance', spawnX:28*TILE, spawnY:10*TILE },
  ],
  particles: 'sparkle',
  darkness: 0.15,
};

// ── ACT 3 MAPS ──
MAPS.underdark_ruins = {
  w: 30, h: 22,
  tiles: buildMap_underdark_ruins(),
  npcs: [
    { id:'wake_trigger', x:5*TILE, y:9*TILE, char:null, isObject:true, sprite:'dark_sign',
      dialogue: () => {
        if (storyFlags.wokeUp) return null;
        storyFlags.wokeUp = true;
        return [
          {who:null, text:t('dlg_act3_wake_1')},
          {who:null, text:t('dlg_act3_wake_2')},
          {who:'hikaru', text:t('dlg_hikaru_wake1')},
          {who:'rina', text:t('dlg_rina_wake1')},
          {who:'hikaru', text:t('dlg_hikaru_wake2')},
          {who:'kenji', text:t('dlg_kenji_wake1')},
        ];
      }
    },
    { id:'warn_spot', x:15*TILE, y:11*TILE, char:null, isObject:true, sprite:'dark_sign',
      dialogue: () => {
        if (storyFlags.warnedFriends) return [{who:'hikaru', text:t('dlg_hikaru_warn2')}];
        storyFlags.warnedFriends = true;
        return [
          {who:'hikaru', text:t('dlg_hikaru_warn1')},
          {who:'rina', text:t('dlg_rina_dismiss1')},
          {who:'kenji', text:t('dlg_kenji_dismiss1')},
          {who:'hikaru', text:t('dlg_hikaru_warn2')},
        ];
      }
    },
    { id:'whisper1', x:10*TILE, y:5*TILE, char:null, isObject:true, sprite:'dark_sign',
      dialogue: () => {
        if (storyFlags.heardWhisper1) return null;
        storyFlags.heardWhisper1 = true;
        objective = t('obj_investigate_whispers');
        return [{who:'hikaru', text:t('dlg_whisper_1')}, {who:'hikaru', text:t('dlg_whisper_2')}];
      }
    },
    { id:'whisper2', x:22*TILE, y:8*TILE, char:null, isObject:true, sprite:'dark_sign',
      dialogue: () => {
        if (storyFlags.heardWhisper2) return null;
        storyFlags.heardWhisper2 = true;
        return [{who:'hikaru', text:t('dlg_whisper_3')}];
      }
    },
  ],
  exits: [
    { x:29, y:10, targetMap:'underdark_dark', spawnX:1*TILE, spawnY:10*TILE, condition: () => storyFlags.warnedFriends },
    { x:29, y:11, targetMap:'underdark_dark', spawnX:1*TILE, spawnY:11*TILE, condition: () => storyFlags.warnedFriends },
  ],
  particles: 'corruption',
  darkness: 0.25,
};

MAPS.underdark_dark = {
  w: 32, h: 20,
  tiles: buildMap_underdark_dark(),
  npcs: [
    { id:'larry_spot', x:20*TILE, y:10*TILE, char:null, isObject:true, sprite:'dark_sign',
      dialogue: () => {
        if (storyFlags.spottedLarry) return null;
        storyFlags.spottedLarry = true;
        objective = t('obj_find_larry');
        return [
          {who:'hikaru', text:t('dlg_larry_spot_1')},
          {who:'rina', text:t('dlg_rina_larry1')},
          {who:'hikaru', text:t('dlg_hikaru_larry1')},
        ];
      }
    },
    { id:'larry_clone', x:26*TILE, y:10*TILE, char:CHARS.larry_fake, dir:2,
      dialogue: () => {
        if (storyFlags.larryRevealed) return null;
        if (!storyFlags.spottedLarry) return [{who:'hikaru', text:t('dlg_hikaru_larry1')}];
        storyFlags.larryRevealed = true;
        return [
          {who:'larry_fake', text:t('dlg_larry_1')},
          {who:'kenji', text:t('dlg_kenji_larry1')},
          {who:'larry_fake', text:t('dlg_larry_2')},
          {who:'hikaru', text:t('dlg_hikaru_larry2')},
          {who:'hikaru', text:t('dlg_hikaru_larry3')},
          {who:'rina', text:t('dlg_rina_larry2')},
          {who:'kenji', text:t('dlg_kenji_larry2')},
          {who:null, text:t('dlg_larry_reveal_1')},
          {who:'larry_fake', text:t('dlg_larry_reveal_2')},
          {who:'larry_fake', text:t('dlg_larry_reveal_3')},
          {who:'rina', text:t('dlg_rina_fight1')},
          {who:'kenji', text:t('dlg_kenji_fight1')},
          {who:'hikaru', text:t('dlg_hikaru_fight1')},
          {who:null, text:'__CLONE_FIGHT_START__'},
        ];
      }
    },
  ],
  exits: [
    { x:0, y:10, targetMap:'underdark_ruins', spawnX:28*TILE, spawnY:10*TILE },
    { x:0, y:11, targetMap:'underdark_ruins', spawnX:28*TILE, spawnY:11*TILE },
  ],
  particles: 'corruption',
  darkness: 0.4,
};

function checkAllTalked() {
  if (storyFlags.talkedRina && storyFlags.talkedKenji) {
    storyFlags.canGoTown = true;
    objective = t('obj_go_town');
  }
}
function checkTownDone() {
  if (storyFlags.talkedOfficer && storyFlags.talkedShop) {
    storyFlags.canGoForest = true;
    objective = t('obj_go_forest');
  }
}
function checkCanGoDepths() {
  if (storyFlags.talkedFairy && storyFlags.foundDarkSign) {
    storyFlags.canGoDepths = true;
    storyFlags.illusionRevealed = true;
    objective = t('obj_find_glen');
  }
}

// ── MAP BUILDERS ──
function buildMap_neighborhood() {
  const m = [];
  for (let y = 0; y < 22; y++) {
    m[y] = [];
    for (let x = 0; x < 30; x++) {
      // Default: grass
      let t = T.GRASS;
      // Paths
      if (y >= 10 && y <= 11 && x >= 0) t = T.PATH;
      if (x >= 8 && x <= 9 && y >= 4 && y <= 10) t = T.PATH;
      if (x >= 16 && x <= 17 && y >= 4 && y <= 10) t = T.PATH;
      // Flowers along paths
      if ((y === 9 || y === 12) && x % 3 === 0 && t === T.GRASS) t = T.FLOWER;
      // Hikaru's house
      if (x >= 3 && x <= 7 && y >= 3 && y <= 5) t = T.WALL;
      if (x >= 3 && x <= 7 && y === 2) t = T.ROOF;
      if (x === 5 && y === 5) t = T.DOOR;
      if ((x === 4 || x === 6) && y === 4) t = T.WINDOW_WALL;
      // Rina's house
      if (x >= 11 && x <= 14 && y >= 4 && y <= 6) t = T.WALL;
      if (x >= 11 && x <= 14 && y === 3) t = T.ROOF;
      if (x === 12 && y === 6) t = T.DOOR;
      if (x === 13 && y === 5) t = T.WINDOW_WALL;
      // Kenji's house
      if (x >= 16 && x <= 20 && y >= 2 && y <= 4) t = T.WALL;
      if (x >= 16 && x <= 20 && y === 1) t = T.ROOF;
      if (x === 18 && y === 4) t = T.DOOR;
      if ((x === 17 || x === 19) && y === 3) t = T.WINDOW_WALL;
      // Trees border
      if (y === 0 && !(x >= 16 && x <= 20)) t = T.TREE;
      if (y === 21) t = T.TREE;
      if (x === 0) t = T.TREE;
      // Water pond
      if (x >= 22 && x <= 25 && y >= 14 && y <= 17) t = T.WATER;
      if (x === 22 && y === 14) t = T.GRASS;
      if (x === 25 && y === 14) t = T.GRASS;
      if (x === 22 && y === 17) t = T.GRASS;
      if (x === 25 && y === 17) t = T.GRASS;
      // Scattered trees
      if ((x === 2 && y === 14) || (x === 6 && y === 17) || (x === 10 && y === 16) ||
          (x === 14 && y === 19) || (x === 26 && y === 3) || (x === 28 && y === 7) ||
          (x === 3 && y === 19) || (x === 22 && y === 8) || (x === 27 && y === 19)) t = T.TREE;
      // Lamp posts
      if ((x === 8 && y === 9) || (x === 16 && y === 9) || (x === 24 && y === 9)) t = T.LAMP;
      // Fence near pond
      if (y === 13 && x >= 21 && x <= 26) t = T.FENCE;
      // Sign
      if (x === 28 && y === 10) t = T.SIGN;
      // Right edge exit
      if (x === 29 && y !== 10 && y !== 11) t = T.FENCE;
      m[y][x] = t;
    }
  }
  return m;
}

function buildMap_town() {
  const m = [];
  for (let y = 0; y < 20; y++) {
    m[y] = [];
    for (let x = 0; x < 32; x++) {
      let t = T.PATH;
      // Green park area
      if (x >= 5 && x <= 15 && y >= 13 && y <= 18) t = T.GRASS;
      if (x >= 7 && x <= 13 && y >= 14 && y <= 17) t = T.FLOWER;
      if ((x === 5 || x === 15) && y >= 13 && y <= 18) t = T.TREE;
      if (y === 13 && x >= 5 && x <= 15) t = T.FENCE;
      if (x === 10 && y === 13) t = T.PATH; // park entrance
      // Main road
      if (y >= 9 && y <= 12) t = T.PATH;
      // Police station
      if (x >= 19 && x <= 25 && y >= 2 && y <= 5) t = T.WALL;
      if (x >= 19 && x <= 25 && y === 1) t = T.ROOF;
      if (x === 22 && y === 5) t = T.DOOR;
      if ((x === 20 || x === 24) && y === 4) t = T.WINDOW_WALL;
      if ((x === 21 || x === 23) && y === 4) t = T.WINDOW_WALL;
      // Shop
      if (x >= 7 && x <= 12 && y >= 4 && y <= 7) t = T.WALL;
      if (x >= 7 && x <= 12 && y === 3) t = T.ROOF;
      if (x === 10 && y === 7) t = T.DOOR;
      if ((x === 8 || x === 11) && y === 6) t = T.WINDOW_WALL;
      // Houses
      if (x >= 2 && x <= 5 && y >= 4 && y <= 6) t = T.WALL;
      if (x >= 2 && x <= 5 && y === 3) t = T.ROOF;
      if (x === 3 && y === 6) t = T.DOOR;
      // More buildings upper right
      if (x >= 27 && x <= 30 && y >= 3 && y <= 5) t = T.WALL;
      if (x >= 27 && x <= 30 && y === 2) t = T.ROOF;
      if (x === 28 && y === 5) t = T.DOOR;
      // Lamp posts
      if ((x === 4 && y === 9) || (x === 12 && y === 9) || (x === 20 && y === 9) || (x === 28 && y === 9)) t = T.LAMP;
      // Borders
      if (y === 0) t = T.FENCE;
      if (y === 19) t = T.FENCE;
      // Right exit
      if (x === 31 && y !== 9 && y !== 10) t = T.FENCE;
      // Sign near police
      if (x === 19 && y === 6) t = T.SIGN;
      // Trees decorating
      if ((x === 17 && y === 8) || (x === 26 && y === 8) || (x === 1 && y === 8)) t = T.TREE;
      if ((x === 17 && y === 13) || (x === 26 && y === 13)) t = T.TREE;
      m[y][x] = t;
    }
  }
  return m;
}

function buildMap_underdark_entrance() {
  const m = [];
  for (let y = 0; y < 20; y++) {
    m[y] = [];
    for (let x = 0; x < 30; x++) {
      let t = T.CRYSTAL_GRASS;
      if (y === 0 || y === 19) t = T.CRYSTAL;
      if (x === 0) t = T.CRYSTAL;
      if (y >= 9 && y <= 11 && x >= 3) t = T.PATH;
      if ((x===4&&y===4)||(x===8&&y===3)||(x===14&&y===5)||(x===22&&y===4)||(x===26&&y===6)||
          (x===6&&y===14)||(x===12&&y===16)||(x===18&&y===15)||(x===24&&y===13)||
          (x===3&&y===8)||(x===25&&y===8)||(x===16&&y===7)) t = T.CRYSTAL;
      if (x >= 13 && x <= 17 && y >= 13 && y <= 15) t = T.WATER;
      if (x === 29 && y !== 9 && y !== 10) t = T.CRYSTAL;
      m[y][x] = t;
    }
  }
  return m;
}

function buildMap_underdark_depths() {
  const m = [];
  for (let y = 0; y < 22; y++) {
    m[y] = [];
    for (let x = 0; x < 32; x++) {
      let t = (x < 16) ? T.CRYSTAL_GRASS : ((x > 20) ? T.DARK_FLOOR : T.CRYSTAL_GRASS);
      if (y >= 10 && y <= 12 && x <= 20) t = T.PATH;
      if (x >= 21 && x <= 29 && y >= 7 && y <= 15) t = T.DARK_FLOOR;
      if (y === 0 || y === 21) t = (x < 16) ? T.CRYSTAL : T.CORRUPT_TREE;
      if (x === 31) t = T.CORRUPT_TREE;
      if ((x===3&&y===5)||(x===7&&y===3)||(x===12&&y===6)||(x===5&&y===15)||(x===10&&y===17)||(x===14&&y===14)) t = T.CRYSTAL;
      if (x === 30 && y >= 5 && y <= 17) t = T.CORRUPT_TREE;
      if (x === 0 && y !== 10 && y !== 11) t = T.CRYSTAL;
      m[y][x] = t;
    }
  }
  return m;
}

function buildMap_underdark_ruins() {
  const m = [];
  for (let y = 0; y < 22; y++) {
    m[y] = [];
    for (let x = 0; x < 30; x++) {
      let t = T.DARK_FLOOR;
      if (y >= 10 && y <= 11 && x >= 2 && x % 3 !== 0) t = T.PATH;
      if (y === 0 || y === 21) t = T.CORRUPT_TREE;
      if (x === 0) t = T.CORRUPT_TREE;
      if ((x===4&&y===3)||(x===8&&y===5)||(x===14&&y===4)||(x===20&&y===3)||(x===26&&y===5)||
          (x===3&&y===14)||(x===9&&y===16)||(x===16&&y===18)||(x===23&&y===15)||(x===27&&y===17)||
          (x===6&&y===8)||(x===18&&y===7)||(x===25&&y===9)) t = T.CORRUPT_TREE;
      if ((x===12&&y===6)||(x===22&&y===4)) t = T.CRYSTAL;
      if (x === 29 && y !== 10 && y !== 11) t = T.CORRUPT_TREE;
      m[y][x] = t;
    }
  }
  return m;
}

function buildMap_underdark_dark() {
  const m = [];
  for (let y = 0; y < 20; y++) {
    m[y] = [];
    for (let x = 0; x < 32; x++) {
      let t = T.DARK_FLOOR;
      if (y === 0 || y === 19) t = T.VOID;
      if (x === 31) t = T.VOID;
      if (x === 0 && y !== 10 && y !== 11) t = T.VOID;
      if ((x===5&&y===3)||(x===10&&y===2)||(x===15&&y===4)||(x===20&&y===3)||
          (x===3&&y===8)||(x===8&&y===6)||(x===13&&y===7)||
          (x===4&&y===14)||(x===9&&y===16)||(x===14&&y===17)||(x===19&&y===15)||
          (x===28&&y===5)||(x===28&&y===15)||(x===7&&y===12)||(x===17&&y===13)) t = T.CORRUPT_TREE;
      if (x >= 24 && x <= 28 && y === 8) t = T.BUSH;
      if (x >= 24 && x <= 28 && y === 12 && (x < 25 || x > 27)) t = T.BUSH;
      if ((x === 24 || x === 28) && y >= 8 && y <= 12) t = T.BUSH;
      m[y][x] = t;
    }
  }
  return m;
}

// Glen's footprints in the forest — trail from path to backpack, then toward portal
const GLEN_FOOTPRINTS = [
  // From path, heading toward backpack
  {x:9, y:11.5}, {x:10.5, y:12}, {x:12, y:12.5}, {x:13.5, y:12.8},
  {x:15, y:12.5}, {x:16.5, y:12.3}, {x:18, y:12.2},
  // Near backpack, then heading north-east toward portal
  {x:21, y:11.5}, {x:22, y:10.5}, {x:23, y:9.5},
  {x:24.5, y:8.5}, {x:25.5, y:7.5}, {x:26.5, y:6.5},
  {x:27.5, y:5.5}, {x:28.5, y:5},
];

function buildMap_forest() {
  const m = [];
  for (let y = 0; y < 24; y++) {
    m[y] = [];
    for (let x = 0; x < 35; x++) {
      let t = T.DARK_GRASS;
      // Winding path
      if (y >= 10 && y <= 12 && x <= 12) t = T.PATH;
      if (x >= 11 && x <= 13 && y >= 7 && y <= 11) t = T.PATH;
      if (y >= 7 && y <= 9 && x >= 12 && x <= 22) t = T.PATH;
      if (x >= 21 && x <= 23 && y >= 5 && y <= 8) t = T.PATH;
      if (y >= 4 && y <= 6 && x >= 22 && x <= 32) t = T.PATH;
      // Dense trees
      for (let i = 0; i < 60; i++) {
        let tx = [0,1,2,3,34,33,32,0,1,34,33,
                  5,7,9,15,17,25,27,29,31,
                  3,6,8,14,16,18,24,26,28,30,
                  4,10,19,23,33,1,2,32,
                  5,11,20,22,34,0,31,
                  7,13,21,24,28,
                  2,8,15,26,30,12,16,20,29,6][i] || 0;
        let ty = [0,0,0,0,0,0,0,23,23,23,23,
                  1,2,1,2,1,2,1,2,1,
                  15,16,17,18,19,15,16,17,18,19,
                  20,21,22,20,21,22,14,14,
                  3,3,3,3,3,13,13,
                  14,15,16,17,20,
                  21,22,23,21,22,14,19,18,15,23][i] || 0;
        if (tx < 35 && ty < 24 && m[ty] && m[ty][tx] === T.DARK_GRASS) m[ty][tx] = T.DEAD_TREE;
      }
      // Rocks
      if ((x === 15 && y === 11) || (x === 18 && y === 6) || (x === 25 && y === 9) ||
          (x === 8 && y === 14) || (x === 28 && y === 3)) t === T.DARK_GRASS ? (m[y] && (m[y][x] = T.ROCK)) : 0;
      // Portal area
      if (x >= 29 && x <= 31 && y >= 4 && y <= 6) {
        if (x === 30 && y === 5) t = T.PORTAL;
      }
      // Borders
      if (y === 0 || y === 23) t = T.DEAD_TREE;
      if (x === 34) t = T.DEAD_TREE;
      if (m[y]) m[y][x] = t;
    }
  }
  // fix rocks properly
  m[11][15] = T.ROCK;
  m[6][18] = T.ROCK;
  m[9][25] = T.ROCK;
  m[14][8] = T.ROCK;
  m[3][28] = T.ROCK;
  return m;
}

// ── PARTICLES ──
let particles = [];
function initParticles(type) {
  particles = [];
  if (type === 'sakura') {
    for (let i = 0; i < 25; i++) {
      particles.push({
        x: Math.random() * 30 * TILE, y: Math.random() * 22 * TILE,
        vx: 0.3 + Math.random() * 0.5, vy: 0.5 + Math.random() * 0.8,
        size: 3 + Math.random() * 3, rot: Math.random() * Math.PI * 2,
        rotSpeed: 0.02 + Math.random() * 0.03, type: 'sakura',
      });
    }
  } else if (type === 'fog') {
    for (let i = 0; i < 15; i++) {
      particles.push({
        x: Math.random() * 35 * TILE, y: Math.random() * 24 * TILE,
        vx: 0.2 + Math.random() * 0.3, vy: 0,
        size: 40 + Math.random() * 60, alpha: 0.1 + Math.random() * 0.15,
        type: 'fog',
      });
    }
  } else if (type === 'sparkle') {
    for (let i = 0; i < 30; i++) {
      particles.push({
        x: Math.random() * 30 * TILE, y: Math.random() * 20 * TILE,
        vx: (Math.random() - 0.5) * 0.3, vy: -0.2 - Math.random() * 0.3,
        size: 2 + Math.random() * 3, alpha: 0.3 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2, type: 'sparkle',
      });
    }
  } else if (type === 'corruption') {
    for (let i = 0; i < 20; i++) {
      particles.push({
        x: Math.random() * 32 * TILE, y: Math.random() * 22 * TILE,
        vx: (Math.random() - 0.5) * 0.4, vy: 0.1 + Math.random() * 0.2,
        size: 5 + Math.random() * 8, alpha: 0.15 + Math.random() * 0.1,
        type: 'corruption',
      });
    }
  }
}

function updateParticles(map) {
  const mw = map.w * TILE, mh = map.h * TILE;
  for (let p of particles) {
    p.x += p.vx; p.y += (p.vy || 0);
    if (p.rot !== undefined) p.rot += p.rotSpeed;
    if (p.x > mw + 20) p.x = -20;
    if (p.y > mh + 20) p.y = -20;
  }
}

function drawParticles() {
  for (let p of particles) {
    let sx = p.x - cam.x, sy = p.y - cam.y;
    if (sx < -60 || sx > W + 60 || sy < -60 || sy > H + 60) continue;
    if (p.type === 'sakura') {
      ctx.save(); ctx.translate(sx, sy); ctx.rotate(p.rot);
      ctx.fillStyle = C.sakura;
      ctx.beginPath();
      ctx.ellipse(0, 0, p.size, p.size * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff9cb0';
      ctx.beginPath();
      ctx.ellipse(1, 1, p.size * 0.5, p.size * 0.3, 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'fog') {
      ctx.fillStyle = `rgba(30,25,50,${p.alpha})`;
      ctx.beginPath();
      ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'sparkle') {
      const st = Date.now() * 0.003;
      const sa = p.alpha * (0.5 + Math.sin(st + p.phase) * 0.5);
      ctx.fillStyle = `rgba(238,221,255,${sa})`;
      ctx.beginPath();
      ctx.arc(sx, sy, p.size * (0.5 + Math.sin(st + p.phase) * 0.3), 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = `rgba(255,255,255,${sa * 0.5})`;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(sx - p.size, sy); ctx.lineTo(sx + p.size, sy);
      ctx.moveTo(sx, sy - p.size); ctx.lineTo(sx, sy + p.size);
      ctx.stroke();
    } else if (p.type === 'corruption') {
      ctx.fillStyle = `rgba(106,42,138,${p.alpha})`;
      ctx.beginPath();
      ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = `rgba(50,10,70,${p.alpha * 0.6})`;
      ctx.beginPath();
      ctx.arc(sx + 2, sy + 2, p.size * 0.6, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ── DRAWING HELPERS ──
function drawTile(x, y, type, mapName) {
  const sx = x * TILE - cam.x, sy = y * TILE - cam.y;
  if (sx < -TILE || sx > W + TILE || sy < -TILE || sy > H + TILE) return;

  switch (type) {
    case T.GRASS:
      ctx.fillStyle = C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      // Grass detail
      ctx.fillStyle = C.grassDark;
      if ((x + y) % 3 === 0) { ctx.fillRect(sx+4, sy+8, 2, 6); ctx.fillRect(sx+7, sy+6, 2, 8); }
      if ((x + y) % 5 === 0) { ctx.fillRect(sx+20, sy+14, 2, 5); ctx.fillRect(sx+23, sy+12, 2, 7); }
      break;
    case T.DARK_GRASS:
      ctx.fillStyle = '#3a5a2a';
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = '#2d4a1e';
      if ((x + y) % 2 === 0) { ctx.fillRect(sx+5, sy+10, 2, 6); ctx.fillRect(sx+18, sy+6, 2, 8); }
      break;
    case T.PATH:
      ctx.fillStyle = C.path;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.pathEdge;
      ctx.fillRect(sx + 2, sy + 2, 4, 4);
      ctx.fillRect(sx + 18, sy + 20, 5, 5);
      ctx.fillRect(sx + 24, sy + 6, 3, 3);
      break;
    case T.WALL:
      ctx.fillStyle = C.wallLight;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.wallDark;
      ctx.fillRect(sx, sy + TILE - 2, TILE, 2);
      ctx.fillRect(sx + TILE - 1, sy, 1, TILE);
      break;
    case T.WINDOW_WALL:
      ctx.fillStyle = C.wallLight;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.window;
      ctx.fillRect(sx + 6, sy + 6, 20, 16);
      ctx.fillStyle = C.windowFrame;
      ctx.fillRect(sx + 5, sy + 5, 22, 2);
      ctx.fillRect(sx + 5, sy + 22, 22, 2);
      ctx.fillRect(sx + 5, sy + 5, 2, 19);
      ctx.fillRect(sx + 25, sy + 5, 2, 19);
      ctx.fillRect(sx + 15, sy + 5, 2, 19);
      break;
    case T.ROOF:
      ctx.fillStyle = C.roof;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.roofDark;
      for (let i = 0; i < TILE; i += 8) ctx.fillRect(sx + i, sy + TILE - 4, 8, 2);
      ctx.fillRect(sx, sy + TILE - 1, TILE, 1);
      break;
    case T.DOOR:
      ctx.fillStyle = C.wallLight;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.door;
      ctx.fillRect(sx + 8, sy + 4, 16, TILE - 4);
      ctx.fillStyle = '#aa8844';
      ctx.fillRect(sx + 20, sy + 16, 3, 3);
      break;
    case T.WATER:
      ctx.fillStyle = C.water;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.waterDeep;
      const wt = Date.now() * 0.001;
      ctx.fillRect(sx + 4 + Math.sin(wt + x) * 3, sy + 8, 12, 2);
      ctx.fillRect(sx + 10 + Math.sin(wt + y) * 3, sy + 20, 10, 2);
      break;
    case T.TREE:
      // base
      ctx.fillStyle = mapName === 'forest' ? '#3a5a2a' : C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      // trunk
      ctx.fillStyle = C.trunk;
      ctx.fillRect(sx + 12, sy + 16, 8, 16);
      // canopy
      ctx.fillStyle = C.tree;
      ctx.beginPath();
      ctx.arc(sx + 16, sy + 10, 14, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = C.treeDark;
      ctx.beginPath();
      ctx.arc(sx + 14, sy + 8, 8, 0, Math.PI * 2);
      ctx.fill();
      break;
    case T.DEAD_TREE:
      ctx.fillStyle = '#3a5a2a';
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.deadTree;
      ctx.fillRect(sx + 13, sy + 8, 6, 24);
      // branches
      ctx.fillRect(sx + 6, sy + 10, 10, 3);
      ctx.fillRect(sx + 16, sy + 6, 10, 3);
      ctx.fillRect(sx + 4, sy + 4, 4, 3);
      ctx.fillRect(sx + 22, sy + 2, 4, 3);
      break;
    case T.ROCK:
      ctx.fillStyle = mapName === 'forest' ? '#3a5a2a' : C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.rock;
      ctx.beginPath();
      ctx.ellipse(sx + 16, sy + 20, 12, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = C.rockDark;
      ctx.beginPath();
      ctx.ellipse(sx + 14, sy + 18, 6, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      break;
    case T.FENCE:
      ctx.fillStyle = mapName === 'forest' ? '#3a5a2a' : C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.fence;
      ctx.fillRect(sx, sy + 10, TILE, 3);
      ctx.fillRect(sx, sy + 20, TILE, 3);
      ctx.fillRect(sx + 4, sy + 6, 3, 20);
      ctx.fillRect(sx + 25, sy + 6, 3, 20);
      break;
    case T.PORTAL:
      ctx.fillStyle = '#3a5a2a';
      ctx.fillRect(sx, sy, TILE, TILE);
      const pt = Date.now() * 0.003;
      ctx.fillStyle = `rgba(120,60,220,${0.3 + Math.sin(pt) * 0.15})`;
      ctx.beginPath();
      ctx.arc(sx + 16, sy + 16, 14 + Math.sin(pt * 1.5) * 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = `rgba(180,100,255,${0.4 + Math.sin(pt + 1) * 0.2})`;
      ctx.beginPath();
      ctx.arc(sx + 16, sy + 16, 8 + Math.sin(pt * 2) * 2, 0, Math.PI * 2);
      ctx.fill();
      break;
    case T.FLOOR:
      ctx.fillStyle = '#d4c4a0';
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = '#c4b490';
      ctx.fillRect(sx + TILE - 1, sy, 1, TILE);
      ctx.fillRect(sx, sy + TILE - 1, TILE, 1);
      break;
    case T.BUSH: {
      const darkBush = mapName === 'underdark_dark' || mapName === 'underdark_ruins';
      ctx.fillStyle = darkBush ? C.darkFloor : C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = darkBush ? C.corruptLeaf : '#3a8030';
      ctx.beginPath();
      ctx.arc(sx + 16, sy + 18, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = darkBush ? C.corruptBranch : '#2a6020';
      ctx.beginPath();
      ctx.arc(sx + 12, sy + 16, 6, 0, Math.PI * 2);
      ctx.fill();
      break;
    }
    case T.FLOWER:
      ctx.fillStyle = C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      const fc = ['#ff6b8a','#ffaa44','#ff55cc','#ffff44','#88ccff'][(x*7+y*3)%5];
      ctx.fillStyle = '#4a8a3a';
      ctx.fillRect(sx + 14, sy + 12, 2, 10);
      ctx.fillStyle = fc;
      ctx.beginPath();
      ctx.arc(sx + 15, sy + 10, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(sx + 15, sy + 10, 2, 0, Math.PI * 2);
      ctx.fill();
      break;
    case T.BRIDGE:
      ctx.fillStyle = '#a08050';
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = '#806030';
      ctx.fillRect(sx, sy, TILE, 3);
      ctx.fillRect(sx, sy + TILE - 3, TILE, 3);
      break;
    case T.SIGN:
      ctx.fillStyle = mapName === 'forest' ? '#3a5a2a' : C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = '#8b6b3e';
      ctx.fillRect(sx + 14, sy + 14, 4, 16);
      ctx.fillStyle = '#c4a060';
      ctx.fillRect(sx + 6, sy + 6, 20, 12);
      ctx.fillStyle = '#8b6b3e';
      ctx.fillRect(sx + 8, sy + 9, 16, 2);
      ctx.fillRect(sx + 10, sy + 13, 12, 2);
      break;
    case T.LAMP:
      ctx.fillStyle = mapName === 'forest' ? '#3a5a2a' : C.grass;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = '#666';
      ctx.fillRect(sx + 14, sy + 10, 4, 22);
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.arc(sx + 16, sy + 8, 5, 0, Math.PI * 2);
      ctx.fill();
      // glow
      ctx.fillStyle = 'rgba(255,215,0,0.15)';
      ctx.beginPath();
      ctx.arc(sx + 16, sy + 8, 18, 0, Math.PI * 2);
      ctx.fill();
      break;
    case T.CRYSTAL_GRASS: {
      ctx.fillStyle = C.crystalGrass;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.crystalGrassDark;
      if ((x + y) % 3 === 0) { ctx.fillRect(sx+4, sy+8, 2, 6); ctx.fillRect(sx+7, sy+6, 2, 8); }
      if ((x + y) % 5 === 0) { ctx.fillRect(sx+20, sy+14, 2, 5); }
      const cgt = Date.now() * 0.002;
      if ((x + y) % 4 === 0) {
        ctx.fillStyle = `rgba(180,255,220,${0.08 + Math.sin(cgt + x * 0.5) * 0.04})`;
        ctx.fillRect(sx, sy, TILE, TILE);
      }
      if (storyFlags.illusionRevealed) {
        ctx.fillStyle = 'rgba(30,10,40,0.3)';
        ctx.fillRect(sx, sy, TILE, TILE);
        ctx.strokeStyle = 'rgba(80,20,100,0.4)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(sx + 2, sy + 16); ctx.lineTo(sx + 30, sy + 12);
        ctx.stroke();
      }
      break;
    }
    case T.CRYSTAL: {
      ctx.fillStyle = C.crystalGrass;
      ctx.fillRect(sx, sy, TILE, TILE);
      const crt = Date.now() * 0.003;
      ctx.fillStyle = C.crystal;
      ctx.beginPath();
      ctx.moveTo(sx + 16, sy + 2); ctx.lineTo(sx + 26, sy + 14);
      ctx.lineTo(sx + 22, sy + 30); ctx.lineTo(sx + 10, sy + 30);
      ctx.lineTo(sx + 6, sy + 14); ctx.closePath(); ctx.fill();
      ctx.fillStyle = `rgba(220,200,255,${0.3 + Math.sin(crt + x) * 0.15})`;
      ctx.beginPath();
      ctx.moveTo(sx + 14, sy + 6); ctx.lineTo(sx + 20, sy + 10);
      ctx.lineTo(sx + 18, sy + 20); ctx.lineTo(sx + 12, sy + 18);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = `${C.crystalGlow}${0.1 + Math.sin(crt) * 0.05})`;
      ctx.beginPath(); ctx.arc(sx + 16, sy + 16, 18, 0, Math.PI * 2); ctx.fill();
      if (storyFlags.illusionRevealed) {
        ctx.fillStyle = 'rgba(40,0,60,0.5)';
        ctx.beginPath(); ctx.arc(sx + 16, sy + 16, 8, 0, Math.PI * 2); ctx.fill();
      }
      break;
    }
    case T.DARK_FLOOR:
      ctx.fillStyle = C.darkFloor;
      ctx.fillRect(sx, sy, TILE, TILE);
      if ((x + y) % 2 === 0) {
        ctx.strokeStyle = C.darkFloorDetail; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(sx + 3, sy + 10); ctx.lineTo(sx + 20, sy + 18);
        ctx.moveTo(sx + 15, sy + 5); ctx.lineTo(sx + 28, sy + 25);
        ctx.stroke();
      }
      break;
    case T.CORRUPT_TREE:
      ctx.fillStyle = C.darkFloor;
      ctx.fillRect(sx, sy, TILE, TILE);
      ctx.fillStyle = C.corruptTree;
      ctx.fillRect(sx + 11, sy + 12, 10, 20);
      ctx.fillStyle = C.corruptBranch;
      ctx.beginPath();
      ctx.moveTo(sx + 8, sy + 14); ctx.lineTo(sx + 2, sy + 4); ctx.lineTo(sx + 6, sy + 2);
      ctx.moveTo(sx + 24, sy + 10); ctx.lineTo(sx + 30, sy + 2); ctx.lineTo(sx + 28, sy + 0);
      ctx.fill();
      ctx.fillStyle = C.corruptLeaf;
      ctx.beginPath(); ctx.arc(sx + 4, sy + 4, 6, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(sx + 28, sy + 2, 5, 0, Math.PI * 2); ctx.fill();
      break;
    case T.VOID: {
      ctx.fillStyle = C.voidColor;
      ctx.fillRect(sx, sy, TILE, TILE);
      const vt = Date.now() * 0.001;
      if ((x * 7 + y * 13) % 5 === 0) {
        ctx.fillStyle = `rgba(100,50,150,${0.1 + Math.sin(vt + x + y) * 0.05})`;
        ctx.beginPath(); ctx.arc(sx + 16, sy + 16, 1, 0, Math.PI * 2); ctx.fill();
      }
      break;
    }
  }
}

function drawFootprints() {
  if (currentMap !== 'forest') return;
  for (let i = 0; i < GLEN_FOOTPRINTS.length; i++) {
    const fp = GLEN_FOOTPRINTS[i];
    const sx = fp.x * TILE - cam.x;
    const sy = fp.y * TILE - cam.y;
    if (sx < -TILE || sx > W + TILE || sy < -TILE || sy > H + TILE) continue;
    const side = (i % 2 === 0) ? -3 : 3;
    ctx.fillStyle = 'rgba(30,20,10,0.3)';
    ctx.beginPath();
    ctx.ellipse(sx + side, sy, 3, 5, 0.2 * (i % 2 ? 1 : -1), 0, Math.PI * 2);
    ctx.fill();
  }
}

// ── CHARACTER DRAWING ──
function drawCharSprite(x, y, char, dir, frame, highlight) {
  const sx = x - cam.x, sy = y - cam.y;
  if (sx < -TILE || sx > W + TILE || sy < -TILE || sy > H + TILE) return;

  // Highlight ring
  if (highlight) {
    ctx.strokeStyle = 'rgba(255,255,100,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(sx + 16, sy + 28, 14, 6, 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  const bounce = Math.sin(frame * 0.3) * 2;
  const isMoving = Math.abs(bounce) > 0.5;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(sx + 16, sy + 30, 10, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Body
  ctx.fillStyle = char.shirt;
  ctx.fillRect(sx + 8, sy + 14 + (isMoving ? bounce * 0.3 : 0), 16, 12);

  // Legs
  ctx.fillStyle = char.pants;
  const legOffset = isMoving ? Math.sin(frame * 0.6) * 3 : 0;
  ctx.fillRect(sx + 9, sy + 24, 5, 6 + legOffset);
  ctx.fillRect(sx + 18, sy + 24, 5, 6 - legOffset);

  // Arms
  ctx.fillStyle = char.skin;
  const armSwing = isMoving ? Math.sin(frame * 0.6) * 2 : 0;
  ctx.fillRect(sx + 4, sy + 15 + armSwing, 5, 8);
  ctx.fillRect(sx + 23, sy + 15 - armSwing, 5, 8);

  // Head
  ctx.fillStyle = char.skin;
  ctx.beginPath();
  ctx.arc(sx + 16, sy + 10 + (isMoving ? bounce * 0.2 : 0), 10, 0, Math.PI * 2);
  ctx.fill();

  // Hair
  ctx.fillStyle = char.hair;
  const hb = isMoving ? bounce * 0.15 : 0;
  if (char.hairStyle === 'spiky') {
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 7 + hb, 11, Math.PI, 0);
    ctx.fill();
    // Spikes
    ctx.beginPath();
    ctx.moveTo(sx + 5, sy + 8); ctx.lineTo(sx + 8, sy - 2 + hb); ctx.lineTo(sx + 12, sy + 6);
    ctx.moveTo(sx + 10, sy + 5); ctx.lineTo(sx + 14, sy - 4 + hb); ctx.lineTo(sx + 18, sy + 4);
    ctx.moveTo(sx + 16, sy + 4); ctx.lineTo(sx + 20, sy - 3 + hb); ctx.lineTo(sx + 24, sy + 6);
    ctx.moveTo(sx + 22, sy + 6); ctx.lineTo(sx + 26, sy - 1 + hb); ctx.lineTo(sx + 28, sy + 8);
    ctx.fill();
  } else if (char.hairStyle === 'long') {
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 7 + hb, 12, Math.PI, 0);
    ctx.fill();
    ctx.fillRect(sx + 4, sy + 7, 4, 16 + hb);
    ctx.fillRect(sx + 24, sy + 7, 4, 16 + hb);
  } else if (char.hairStyle === 'short') {
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 7 + hb, 11, Math.PI, Math.PI * 0.05);
    ctx.fill();
  } else if (char.hairStyle === 'messy') {
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 7 + hb, 12, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(sx + 6, sy + 5); ctx.lineTo(sx + 3, sy + 0 + hb); ctx.lineTo(sx + 10, sy + 5);
    ctx.moveTo(sx + 20, sy + 3); ctx.lineTo(sx + 24, sy - 2 + hb); ctx.lineTo(sx + 27, sy + 5);
    ctx.fill();
  } else if (char.hairStyle === 'bun') {
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 7 + hb, 11, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(sx + 16, sy - 1 + hb, 5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Eyes
  if (dir !== 1) { // not facing up
    ctx.fillStyle = '#fff';
    ctx.fillRect(sx + 10, sy + 8, 5, 5);
    ctx.fillRect(sx + 18, sy + 8, 5, 5);
    ctx.fillStyle = char.eyes;
    ctx.fillRect(sx + 12, sy + 9, 3, 4);
    ctx.fillRect(sx + 20, sy + 9, 3, 4);
    // Eye shine
    ctx.fillStyle = '#fff';
    ctx.fillRect(sx + 13, sy + 9, 1, 1);
    ctx.fillRect(sx + 21, sy + 9, 1, 1);
  }
}

function drawObjectSprite(x, y, type) {
  const sx = x - cam.x, sy = y - cam.y;
  if (sx < -TILE*2 || sx > W + TILE*2 || sy < -TILE*2 || sy > H + TILE*2) return;

  if (type === 'backpack') {
    // Highlight ring
    ctx.strokeStyle = 'rgba(255,200,50,0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(sx + 16, sy + 28, 10, 5, 0, 0, Math.PI * 2);
    ctx.stroke();
    // Backpack body
    ctx.fillStyle = '#3388cc';
    ctx.beginPath();
    ctx.roundRect(sx + 6, sy + 8, 20, 18, 4);
    ctx.fill();
    ctx.fillStyle = '#2266aa';
    ctx.beginPath();
    ctx.roundRect(sx + 8, sy + 14, 16, 8, 3);
    ctx.fill();
    // Straps
    ctx.fillStyle = '#225588';
    ctx.fillRect(sx + 8, sy + 4, 3, 8);
    ctx.fillRect(sx + 21, sy + 4, 3, 8);
    // Buckle
    ctx.fillStyle = '#ccc';
    ctx.fillRect(sx + 14, sy + 16, 4, 3);
  } else if (type === 'portal') {
    const pt = Date.now() * 0.003;
    // Outer glow
    ctx.fillStyle = `rgba(100,40,200,${0.15 + Math.sin(pt) * 0.05})`;
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 16, 40 + Math.sin(pt) * 5, 0, Math.PI * 2);
    ctx.fill();
    // Middle ring
    ctx.strokeStyle = `rgba(160,80,255,${0.5 + Math.sin(pt * 1.3) * 0.2})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 16, 25 + Math.sin(pt * 1.5) * 3, 0, Math.PI * 2);
    ctx.stroke();
    // Inner swirl
    ctx.fillStyle = `rgba(200,120,255,${0.6 + Math.sin(pt * 2) * 0.2})`;
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 16, 12 + Math.sin(pt * 2) * 2, 0, Math.PI * 2);
    ctx.fill();
    // Core
    ctx.fillStyle = `rgba(255,200,255,${0.7 + Math.sin(pt * 3) * 0.2})`;
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 16, 5, 0, Math.PI * 2);
    ctx.fill();
    // Floating particles
    for (let i = 0; i < 6; i++) {
      const a = pt + i * Math.PI / 3;
      const r = 18 + Math.sin(pt * 2 + i) * 6;
      ctx.fillStyle = `rgba(180,100,255,${0.5 + Math.sin(pt + i) * 0.3})`;
      ctx.beginPath();
      ctx.arc(sx + 16 + Math.cos(a) * r, sy + 16 + Math.sin(a) * r, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  } else if (type === 'dark_sign') {
    const dst = Date.now() * 0.002;
    ctx.fillStyle = `rgba(80,20,100,${0.2 + Math.sin(dst) * 0.1})`;
    ctx.beginPath();
    ctx.ellipse(sx + 16, sy + 20, 12, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = `rgba(160,60,200,${0.15 + Math.sin(dst * 1.5) * 0.1})`;
    ctx.beginPath();
    ctx.arc(sx + 16, sy + 18, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = `rgba(200,100,255,${0.3 + Math.sin(dst * 2) * 0.15})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.ellipse(sx + 16, sy + 20, 14, 10, 0, 0, Math.PI * 2);
    ctx.stroke();
  }
}

// ── DIALOGUE PORTRAIT ──
function drawPortrait(char, x, y, size) {
  if (!char) return;
  const s = size;
  // Background circle
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.arc(x + s/2, y + s/2, s/2 + 2, 0, Math.PI * 2);
  ctx.fill();

  // Face
  ctx.fillStyle = char.skin;
  ctx.beginPath();
  ctx.arc(x + s/2, y + s * 0.48, s * 0.35, 0, Math.PI * 2);
  ctx.fill();

  // Hair
  ctx.fillStyle = char.hair;
  if (char.hairStyle === 'spiky') {
    ctx.beginPath();
    ctx.arc(x + s/2, y + s * 0.38, s * 0.38, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + s*0.15, y + s*0.35); ctx.lineTo(x + s*0.25, y + s*0.05); ctx.lineTo(x + s*0.4, y + s*0.25);
    ctx.moveTo(x + s*0.3, y + s*0.2); ctx.lineTo(x + s*0.45, y); ctx.lineTo(x + s*0.6, y + s*0.15);
    ctx.moveTo(x + s*0.55, y + s*0.15); ctx.lineTo(x + s*0.7, y + s*0.02); ctx.lineTo(x + s*0.8, y + s*0.25);
    ctx.fill();
  } else if (char.hairStyle === 'long') {
    ctx.beginPath();
    ctx.arc(x + s/2, y + s * 0.35, s * 0.4, Math.PI, 0);
    ctx.fill();
    ctx.fillRect(x + s*0.1, y + s*0.35, s*0.15, s*0.45);
    ctx.fillRect(x + s*0.75, y + s*0.35, s*0.15, s*0.45);
    // Bangs
    ctx.beginPath();
    ctx.moveTo(x + s*0.2, y + s*0.35); ctx.lineTo(x + s*0.3, y + s*0.5); ctx.lineTo(x + s*0.4, y + s*0.35);
    ctx.fill();
  } else if (char.hairStyle === 'short') {
    ctx.beginPath();
    ctx.arc(x + s/2, y + s * 0.38, s * 0.38, Math.PI, 0.05);
    ctx.fill();
  } else if (char.hairStyle === 'messy') {
    ctx.beginPath();
    ctx.arc(x + s/2, y + s * 0.38, s * 0.4, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + s*0.15, y + s*0.3); ctx.lineTo(x + s*0.05, y + s*0.1); ctx.lineTo(x + s*0.3, y + s*0.25);
    ctx.moveTo(x + s*0.65, y + s*0.2); ctx.lineTo(x + s*0.85, y + s*0.05); ctx.lineTo(x + s*0.9, y + s*0.3);
    ctx.fill();
  } else if (char.hairStyle === 'bun') {
    ctx.beginPath();
    ctx.arc(x + s/2, y + s * 0.38, s * 0.38, Math.PI, 0);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x + s/2, y + s * 0.1, s * 0.14, 0, Math.PI * 2);
    ctx.fill();
  }

  // Big anime eyes
  const ey = y + s * 0.44;
  // White
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.ellipse(x + s*0.35, ey, s*0.1, s*0.12, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x + s*0.65, ey, s*0.1, s*0.12, 0, 0, Math.PI*2); ctx.fill();
  // Iris
  ctx.fillStyle = char.eyes;
  ctx.beginPath(); ctx.ellipse(x + s*0.35, ey + s*0.02, s*0.07, s*0.09, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(x + s*0.65, ey + s*0.02, s*0.07, s*0.09, 0, 0, Math.PI*2); ctx.fill();
  // Pupil
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(x + s*0.35, ey + s*0.03, s*0.035, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + s*0.65, ey + s*0.03, s*0.035, 0, Math.PI*2); ctx.fill();
  // Shine
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(x + s*0.32, ey - s*0.01, s*0.025, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + s*0.62, ey - s*0.01, s*0.025, 0, Math.PI*2); ctx.fill();

  // Mouth
  ctx.strokeStyle = '#c08060';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(x + s/2, y + s*0.6, s*0.06, 0.1, Math.PI - 0.1);
  ctx.stroke();

  // Neck/shoulders hint
  ctx.fillStyle = char.shirt;
  ctx.beginPath();
  ctx.moveTo(x + s*0.25, y + s*0.75);
  ctx.lineTo(x + s*0.1, y + s);
  ctx.lineTo(x + s*0.9, y + s);
  ctx.lineTo(x + s*0.75, y + s*0.75);
  ctx.fill();
  ctx.fillStyle = char.skin;
  ctx.fillRect(x + s*0.42, y + s*0.68, s*0.16, s*0.1);
}

// ── DIALOGUE SYSTEM ──
let dialogueQueue = [];
let dialogueIndex = 0;
let dialogueText = '';
let dialogueTimer = 0;
let dialogueCharIndex = 0;
let dialogueSpeed = 30; // ms per character
let currentSpeaker = null;

function startDialogue(lines) {
  dialogueQueue = lines;
  dialogueIndex = 0;
  dialogueCharIndex = 0;
  dialogueTimer = 0;
  dialogueText = '';
  gameState = 'dialogue';
  if (lines[0]) currentSpeaker = lines[0].who;
}

function updateDialogue(dt) {
  if (dialogueIndex >= dialogueQueue.length) {
    gameState = returnToBoss ? 'boss' : 'playing';
    returnToBoss = false;
    dialogueQueue = [];
    return;
  }
  const line = dialogueQueue[dialogueIndex];
  if (line.text === '__ENDING__' || line.text === '__ENDING_ACT2__' || line.text === '__ENDING_ACT3__') {
    gameState = 'ending';
    endingTimer = 0;
    return;
  }
  if (line.text === '__BOSS_START__') {
    gameState = 'boss';
    initBossFight();
    return;
  }
  if (line.text === '__CLONE_FIGHT_START__') {
    gameState = 'boss';
    initCloneFight();
    return;
  }
  if (line.text === '__GLEN_SACRIFICE__') {
    bossState.phase = 'sacrifice';
    storyFlags.bossDefeated = true;
    startDialogue([
      {who:null, text:t('dlg_glen_sacrifice_1')},
      {who:'glen_boss', text:t('dlg_glen_sacrifice_2')},
      {who:'glen_boss', text:t('dlg_glen_sacrifice_3')},
      {who:'glen_boss', text:t('dlg_glen_sacrifice_4')},
      {who:'rina', text:t('dlg_rina_sacrifice')},
      {who:'glen_boss', text:t('dlg_glen_sacrifice_5')},
      {who:null, text:t('dlg_glen_sacrifice_6')},
      {who:null, text:'__ENDING_ACT2__'},
    ]);
    return;
  }
  currentSpeaker = line.who;
  dialogueTimer += dt;
  if (dialogueCharIndex < line.text.length) {
    while (dialogueTimer >= dialogueSpeed && dialogueCharIndex < line.text.length) {
      dialogueTimer -= dialogueSpeed;
      dialogueCharIndex++;
      dialogueText = line.text.substring(0, dialogueCharIndex);
    }
  }
  if (tapAction) {
    tapAction = false;
    if (dialogueCharIndex < line.text.length) {
      dialogueCharIndex = line.text.length;
      dialogueText = line.text;
    } else {
      dialogueIndex++;
      dialogueCharIndex = 0;
      dialogueTimer = 0;
      dialogueText = '';
    }
  }
}

function drawDialogue() {
  const boxH = Math.min(160, H * 0.28);
  const boxY = H - boxH - 10;
  const boxX = 10;
  const boxW = W - 20;

  // Box background
  ctx.fillStyle = 'rgba(10,5,30,0.88)';
  ctx.beginPath();
  ctx.roundRect(boxX, boxY, boxW, boxH, 12);
  ctx.fill();

  // Border
  ctx.strokeStyle = 'rgba(150,120,255,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(boxX, boxY, boxW, boxH, 12);
  ctx.stroke();

  // Portrait
  const portraitSize = Math.min(70, boxH - 20);
  const char = currentSpeaker ? CHARS[currentSpeaker] : null;
  if (char) {
    drawPortrait(char, boxX + 10, boxY + (boxH - portraitSize) / 2, portraitSize);
  }

  // Name
  const textX = char ? boxX + portraitSize + 25 : boxX + 20;
  if (currentSpeaker && char) {
    ctx.fillStyle = char.hair;
    ctx.font = 'bold 15px "Segoe UI", sans-serif';
    const displayName = currentSpeaker === 'officer' ? t('name_officer') : currentSpeaker === 'shopkeeper' ? t('name_shopkeeper') : currentSpeaker === 'larry_fake' ? t('name_larry') : currentSpeaker === 'glen_boss' ? t('name_glen_boss') : currentSpeaker === 'fairy' ? '???' : char.name;
    ctx.fillText(displayName, textX, boxY + 22);
  } else if (!currentSpeaker) {
    ctx.fillStyle = '#aaa';
    ctx.font = 'italic 14px "Segoe UI", sans-serif';
  }

  // Text
  ctx.fillStyle = '#eee';
  ctx.font = '14px "Segoe UI", sans-serif';
  const maxWidth = boxW - (char ? portraitSize + 45 : 40);
  wrapText(dialogueText, textX, boxY + 42, maxWidth, 20);

  // Continue indicator
  if (dialogueCharIndex >= (dialogueQueue[dialogueIndex]?.text?.length || 0)) {
    const blinkAlpha = 0.4 + Math.sin(Date.now() * 0.005) * 0.4;
    ctx.fillStyle = `rgba(200,180,255,${blinkAlpha})`;
    ctx.font = '16px sans-serif';
    ctx.fillText('▼', boxX + boxW - 30, boxY + boxH - 15);
  }
}

function wrapText(text, x, y, maxWidth, lineHeight) {
  const words = text.split(' ');
  let line = '';
  let testLine, metrics;
  let ly = y;
  for (let n = 0; n < words.length; n++) {
    testLine = line + words[n] + ' ';
    metrics = ctx.measureText(testLine);
    if (metrics.width > maxWidth && n > 0) {
      ctx.fillText(line, x, ly);
      line = words[n] + ' ';
      ly += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, x, ly);
}

// ── UI ──
function drawUI() {
  // Objective bar
  ctx.font = 'bold 11px "Segoe UI", sans-serif';
  const objLabel = t('ui_objective');
  const objLabelWidth = ctx.measureText(objLabel).width;
  ctx.font = '12px "Segoe UI", sans-serif';
  const objTextWidth = ctx.measureText(objective).width;
  const objBarW = Math.min(W - 20, objLabelWidth + objTextWidth + 40);
  ctx.fillStyle = 'rgba(10,5,30,0.7)';
  ctx.beginPath();
  ctx.roundRect(10, 10, objBarW, 36, 8);
  ctx.fill();
  ctx.strokeStyle = 'rgba(150,120,255,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(10, 10, objBarW, 36, 8);
  ctx.stroke();
  ctx.fillStyle = '#c8b8ff';
  ctx.font = 'bold 11px "Segoe UI", sans-serif';
  ctx.fillText(objLabel, 20, 26);
  ctx.fillStyle = '#eee';
  ctx.font = '12px "Segoe UI", sans-serif';
  ctx.fillText(objective, 20 + objLabelWidth + 10, 26);

  // Action button hint
  if (nearbyInteractable()) {
    const bx = W - 70, by = H - 140;
    ctx.fillStyle = 'rgba(255,200,50,0.25)';
    ctx.beginPath();
    ctx.arc(bx + 25, by + 25, 28, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,200,50,0.7)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(bx + 25, by + 25, 28, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(t('ui_talk'), bx + 25, by + 30);
    ctx.textAlign = 'start';
  }

  // Virtual joystick
  if (joystick.active) {
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath();
    ctx.arc(joystick.sx, joystick.sy, 50, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(joystick.sx + joystick.dx * 50, joystick.sy + joystick.dy * 50, 20, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ── INTERACTION ──
function nearbyInteractable() {
  const map = MAPS[currentMap];
  for (let npc of map.npcs) {
    // Skip NPCs that are now active followers
    if (npc.id === 'rina' && followers[0].active) continue;
    if (npc.id === 'kenji' && followers[1].active) continue;
    const dx = (player.x + 16) - (npc.x + 16);
    const dy = (player.y + 16) - (npc.y + 16);
    if (Math.sqrt(dx * dx + dy * dy) < INTERACT_DIST) return npc;
  }
  return null;
}

function tryInteract() {
  const npc = nearbyInteractable();
  if (npc && npc.dialogue) {
    const lines = npc.dialogue();
    if (lines && lines.length > 0) startDialogue(lines);
  }
}

// ── BOSS FIGHT SYSTEM ──
function initBossFight() {
  const arenaX = 21 * TILE, arenaY = 7 * TILE;
  const arenaW = 9 * TILE, arenaH = 9 * TILE;
  bossState = {
    type: 'glen',
    phase: 'fighting', // fighting, approach_dialogue, sacrifice
    glen: { x: 25 * TILE, y: 11 * TILE },
    projectiles: [],
    spawnTimer: 0,
    spawnInterval: 800,
    approachCount: 0,
    invuln: 0,
    arena: { x: arenaX, y: arenaY, w: arenaW, h: arenaH },
    timer: 0,
    patternIndex: 0,
  };
  // Position player at arena entrance
  player.x = 21 * TILE;
  player.y = 11 * TILE;
  // Park followers at arena edge
  for (let i = 0; i < followers.length; i++) {
    if (followers[i].active) {
      followers[i].x = 20 * TILE;
      followers[i].y = (10 + i * 2) * TILE;
      followers[i].moving = false;
    }
  }
}

function initCloneFight() {
  bossState = {
    type: 'clone',
    phase: 'fighting',
    clone: { x: 26 * TILE, y: 10 * TILE },
    projectiles: [],
    spawnTimer: 0,
    spawnInterval: 600,
    invuln: 0,
    arena: { x: 22 * TILE, y: 6 * TILE, w: 8 * TILE, h: 8 * TILE },
    timer: 0,
    surviveTime: 15000,
    patternIndex: 0,
  };
  player.x = 23 * TILE;
  player.y = 10 * TILE;
  objective = t('obj_survive_larry');
}

function spawnBossProjectiles() {
  const bs = bossState;
  const bx = bs.type === 'glen' ? bs.glen.x + 16 : bs.clone.x + 16;
  const by = bs.type === 'glen' ? bs.glen.y + 16 : bs.clone.y + 16;
  const px = player.x + 16, py = player.y + 16;
  const pattern = bs.patternIndex % 3;
  bs.patternIndex++;

  if (pattern === 0) {
    // Direct shot at player
    const dx = px - bx, dy = py - by;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    bs.projectiles.push({ x: bx, y: by, vx: dx / dist * 2.5, vy: dy / dist * 2.5, life: 3000 });
  } else if (pattern === 1) {
    // Spread of 3
    const dx = px - bx, dy = py - by;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    const baseAngle = Math.atan2(dy, dx);
    for (let i = -1; i <= 1; i++) {
      const a = baseAngle + i * 0.3;
      bs.projectiles.push({ x: bx, y: by, vx: Math.cos(a) * 2.2, vy: Math.sin(a) * 2.2, life: 3000 });
    }
  } else {
    // Ring of 6
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI * 2 / 6) * i + bs.timer * 0.001;
      bs.projectiles.push({ x: bx, y: by, vx: Math.cos(a) * 1.8, vy: Math.sin(a) * 1.8, life: 3000 });
    }
  }
}

function updateBossFight(dt) {
  const bs = bossState;
  if (!bs || bs.phase !== 'fighting') return;
  bs.timer += dt;
  if (bs.invuln > 0) bs.invuln -= dt;

  // Player movement in boss arena
  let dx = joystick.dx * SPEED;
  let dy = joystick.dy * SPEED;
  player.moving = (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1);
  if (player.moving) {
    if (Math.abs(dx) > Math.abs(dy)) player.dir = dx > 0 ? 3 : 2;
    else player.dir = dy > 0 ? 0 : 1;
    player.animTimer += ANIM_SPEED;
    player.frame = player.animTimer;
    // Constrain to arena
    let nx = Math.max(bs.arena.x + 4, Math.min(bs.arena.x + bs.arena.w - 28, player.x + dx));
    let ny = Math.max(bs.arena.y + 4, Math.min(bs.arena.y + bs.arena.h - 28, player.y + dy));
    player.x = nx;
    player.y = ny;
  }

  // Spawn projectiles
  bs.spawnTimer += dt;
  if (bs.spawnTimer >= bs.spawnInterval) {
    bs.spawnTimer = 0;
    spawnBossProjectiles();
    // Speed up slightly over time
    if (bs.spawnInterval > 400) bs.spawnInterval -= 5;
  }

  // Update projectiles
  for (let i = bs.projectiles.length - 1; i >= 0; i--) {
    const p = bs.projectiles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
    if (p.life <= 0 || p.x < bs.arena.x - 32 || p.x > bs.arena.x + bs.arena.w + 32 ||
        p.y < bs.arena.y - 32 || p.y > bs.arena.y + bs.arena.h + 32) {
      bs.projectiles.splice(i, 1);
    }
  }

  // Collision with player
  if (bs.invuln <= 0) {
    const px = player.x + 16, py = player.y + 16;
    for (let p of bs.projectiles) {
      const ddx = p.x - px, ddy = p.y - py;
      if (ddx * ddx + ddy * ddy < 18 * 18) {
        // Hit — push player to arena edge, invuln
        bs.invuln = 1000;
        const pushX = bs.arena.x + bs.arena.w / 2 > px ? bs.arena.x + 8 : bs.arena.x + bs.arena.w - 40;
        const pushY = bs.arena.y + bs.arena.h / 2 > py ? bs.arena.y + 8 : bs.arena.y + bs.arena.h - 40;
        player.x = pushX;
        player.y = pushY;
        bs.projectiles = [];
        break;
      }
    }
  }

  // Check approach (Glen boss)
  if (bs.type === 'glen') {
    const adx = player.x - bs.glen.x, ady = player.y - bs.glen.y;
    if (adx * adx + ady * ady < 40 * 40) {
      bs.approachCount++;
      bs.projectiles = [];
      // Push player back
      player.x = bs.arena.x + 8;
      player.y = bs.arena.y + bs.arena.h / 2;
      if (bs.approachCount >= 3) {
        // Sacrifice trigger
        bs.phase = 'sacrifice';
        returnToBoss = false;
        startDialogue([
          {who:'hikaru', text:t('dlg_boss_approach_3')},
          {who:'glen_boss', text:t('dlg_glen_fight_3')},
          {who:null, text:'__GLEN_SACRIFICE__'},
        ]);
      } else {
        // Approach dialogue
        returnToBoss = true;
        const approachKey = 'dlg_boss_approach_' + bs.approachCount;
        const fightKey = 'dlg_glen_fight_' + bs.approachCount;
        startDialogue([
          {who:'hikaru', text:t(approachKey)},
          {who:'glen_boss', text:t(fightKey)},
        ]);
      }
    }
  }

  // Clone fight — survive timer
  if (bs.type === 'clone') {
    if (bs.timer >= bs.surviveTime) {
      bs.phase = 'done';
      storyFlags.cloneDefeated = true;
      startDialogue([
        {who:null, text:t('dlg_clone_defeat_1')},
        {who:'rina', text:t('dlg_rina_after1')},
        {who:'kenji', text:t('dlg_kenji_after1')},
        {who:'hikaru', text:t('dlg_hikaru_after1')},
        {who:'hikaru', text:t('dlg_hikaru_after2')},
        {who:null, text:t('dlg_end3_narration')},
        {who:null, text:'__ENDING_ACT3__'},
      ]);
    }
  }
}

function drawBossFight() {
  const bs = bossState;
  if (!bs) return;
  const map = MAPS[currentMap];

  // Camera follows player
  cam.x = player.x - W / 2 + 16;
  cam.y = player.y - H / 2 + 16;
  cam.x = Math.max(0, Math.min(map.w * TILE - W, cam.x));
  cam.y = Math.max(0, Math.min(map.h * TILE - H, cam.y));

  // Draw tiles
  const startX = Math.max(0, Math.floor(cam.x / TILE));
  const startY = Math.max(0, Math.floor(cam.y / TILE));
  const endX = Math.min(map.w - 1, Math.ceil((cam.x + W) / TILE));
  const endY = Math.min(map.h - 1, Math.ceil((cam.y + H) / TILE));
  for (let y = startY; y <= endY; y++) {
    for (let x = startX; x <= endX; x++) {
      drawTile(x, y, map.tiles[y][x], currentMap);
    }
  }

  // Draw boss with dark aura
  const bossChar = bs.type === 'glen' ? CHARS.glen_boss : CHARS.larry_fake;
  const bx = bs.type === 'glen' ? bs.glen.x : bs.clone.x;
  const by = bs.type === 'glen' ? bs.glen.y : bs.clone.y;
  const screenBx = bx - cam.x, screenBy = by - cam.y;
  // Aura
  const tt = Date.now() * 0.003;
  ctx.fillStyle = `rgba(120,40,200,${0.15 + Math.sin(tt) * 0.08})`;
  ctx.beginPath();
  ctx.arc(screenBx + 16, screenBy + 16, 30 + Math.sin(tt * 2) * 5, 0, Math.PI * 2);
  ctx.fill();
  drawCharSprite(bx, by, bossChar, 2, 0, false);

  // Draw followers static at edge
  for (let f of followers) {
    if (f.active) {
      drawCharSprite(f.x, f.y, f.char, f.dir, 0, false);
    }
  }

  // Draw player
  if (bs.invuln > 0 && Math.floor(bs.invuln / 100) % 2 === 0) {
    ctx.globalAlpha = 0.4;
  }
  drawCharSprite(player.x, player.y, player.char, player.dir, player.frame, false);
  ctx.globalAlpha = 1;

  // Draw projectiles
  for (let p of bs.projectiles) {
    const sx = p.x - cam.x, sy = p.y - cam.y;
    ctx.fillStyle = 'rgba(160,60,255,0.8)';
    ctx.beginPath();
    ctx.arc(sx, sy, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(220,160,255,0.5)';
    ctx.beginPath();
    ctx.arc(sx, sy, 10, 0, Math.PI * 2);
    ctx.fill();
  }

  // Particles
  drawParticles();

  // Darkness overlay
  if (map.darkness) {
    ctx.fillStyle = `rgba(10,5,25,${map.darkness})`;
    ctx.fillRect(0, 0, W, H);
    const px = player.x + 16 - cam.x, py = player.y + 16 - cam.y;
    const grad = ctx.createRadialGradient(px, py, 30, px, py, 180);
    grad.addColorStop(0, 'rgba(10,5,25,0.35)');
    grad.addColorStop(1, 'rgba(10,5,25,0)');
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    ctx.globalCompositeOperation = 'source-over';
  }

  // Hit flash overlay
  if (bs.invuln > 800) {
    ctx.fillStyle = `rgba(200,50,50,${(bs.invuln - 800) / 200 * 0.3})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Clone fight timer bar
  if (bs.type === 'clone' && bs.phase === 'fighting') {
    const progress = Math.min(bs.timer / bs.surviveTime, 1);
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(W / 2 - 80, 16, 160, 12);
    ctx.fillStyle = `rgb(${Math.floor(200 - progress * 150)},${Math.floor(50 + progress * 150)},80)`;
    ctx.fillRect(W / 2 - 79, 17, 158 * progress, 10);
    ctx.strokeStyle = 'rgba(200,160,255,0.6)';
    ctx.lineWidth = 1;
    ctx.strokeRect(W / 2 - 80, 16, 160, 12);
  }

  // UI overlay
  drawUI();

  // Dialogue on top if active
  if (gameState === 'dialogue') {
    drawDialogue();
  }
}

// ── GAME LOOP ──
let lastTime = 0;
function gameLoop(time) {
  const dt = Math.min(time - lastTime, 50);
  lastTime = time;

  // Keyboard input
  if (gameState === 'playing' || gameState === 'boss') {
    let kdx = 0, kdy = 0;
    if (keys['ArrowLeft'] || keys['a']) kdx = -1;
    if (keys['ArrowRight'] || keys['d']) kdx = 1;
    if (keys['ArrowUp'] || keys['w']) kdy = -1;
    if (keys['ArrowDown'] || keys['s']) kdy = 1;
    if (kdx || kdy) {
      const len = Math.sqrt(kdx*kdx + kdy*kdy);
      joystick.dx = kdx / len; joystick.dy = kdy / len;
    } else if (!joystick.active) {
      joystick.dx = 0; joystick.dy = 0;
    }
  }

  update(dt);
  draw();
  if (actionBtn.pressed) { actionBtn.pressed = false; }
  requestAnimationFrame(gameLoop);
}

function update(dt) {
  if (gameState === 'transition') {
    transitionAlpha += 0.04;
    if (transitionAlpha >= 1) {
      currentMap = transitionTarget;
      player.x = transitionSpawn.x;
      player.y = transitionSpawn.y;
      // Reposition active followers near spawn
      for (let i = 0; i < followers.length; i++) {
        if (followers[i].active) {
          followers[i].x = transitionSpawn.x;
          followers[i].y = transitionSpawn.y + (i + 1) * TILE;
          followers[i].dir = player.dir;
          followers[i].moving = false;
        }
      }
      // Reseed trail
      trail = [];
      for (let i = 0; i < TRAIL_SPACING * followers.length + 10; i++) trail.push({x: player.x, y: player.y});
      initParticles(MAPS[currentMap].particles);
      transitionAlpha = 1;
      // Set objective for new map
      if (currentMap === 'town' && !storyFlags.talkedOfficer) objective = t('obj_investigate_town');
      if (currentMap === 'forest') objective = t('obj_search_forest');
      if (currentMap === 'neighborhood' && storyFlags.canGoTown) objective = t('obj_go_town');
      if (currentMap === 'underdark_entrance') objective = t('obj_explore_underdark');
      if (currentMap === 'underdark_depths') objective = t('obj_find_glen');
      if (currentMap === 'underdark_ruins') objective = t('obj_follow_friends');
      if (currentMap === 'underdark_dark') objective = t('obj_investigate_whispers');
    }
    if (transitionAlpha >= 1) {
      // Fade back in
      gameState = 'fadein';
    }
    return;
  }
  if (gameState === 'fadein') {
    transitionAlpha -= 0.04;
    if (transitionAlpha <= 0) {
      transitionAlpha = 0;
      gameState = 'playing';
    }
    return;
  }
  if (gameState === 'dialogue') {
    updateDialogue(dt);
    return;
  }
  if (gameState === 'ending') {
    endingTimer += dt;
    if (tapAction && endingTimer >= 8000 && currentAct < 3) {
      tapAction = false;
      if (currentAct === 1) {
        currentAct = 2;
        transitionTarget = 'underdark_entrance';
        transitionSpawn = { x: 15 * TILE, y: 18 * TILE };
        objective = t('obj_explore_underdark');
      } else if (currentAct === 2) {
        currentAct = 3;
        transitionTarget = 'underdark_ruins';
        transitionSpawn = { x: 5 * TILE, y: 10 * TILE };
        objective = t('obj_follow_friends');
      }
      endingTimer = 0;
      transitionAlpha = 0;
      gameState = 'transition';
    }
    return;
  }
  if (gameState === 'boss') {
    updateBossFight(dt);
    updateParticles(MAPS[currentMap]);
    return;
  }
  if (gameState !== 'playing') return;

  const map = MAPS[currentMap];

  // Movement
  let dx = joystick.dx * SPEED;
  let dy = joystick.dy * SPEED;
  player.moving = (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1);

  if (player.moving) {
    // Direction
    if (Math.abs(dx) > Math.abs(dy)) {
      player.dir = dx > 0 ? 3 : 2;
    } else {
      player.dir = dy > 0 ? 0 : 1;
    }
    player.animTimer += ANIM_SPEED;
    player.frame = player.animTimer;

    // Collision X
    let nx = player.x + dx;
    let tileX1 = Math.floor((nx + 6) / TILE);
    let tileX2 = Math.floor((nx + 26) / TILE);
    let tileY1 = Math.floor((player.y + 12) / TILE);
    let tileY2 = Math.floor((player.y + 30) / TILE);
    let canMoveX = true;
    for (let ty = tileY1; ty <= tileY2; ty++) {
      for (let tx = tileX1; tx <= tileX2; tx++) {
        if (ty < 0 || ty >= map.h || tx < 0 || tx >= map.w || !WALKABLE.has(map.tiles[ty][tx])) {
          canMoveX = false; break;
        }
      }
      if (!canMoveX) break;
    }
    if (canMoveX) player.x = nx;

    // Collision Y
    let ny = player.y + dy;
    tileX1 = Math.floor((player.x + 6) / TILE);
    tileX2 = Math.floor((player.x + 26) / TILE);
    tileY1 = Math.floor((ny + 12) / TILE);
    tileY2 = Math.floor((ny + 30) / TILE);
    let canMoveY = true;
    for (let ty = tileY1; ty <= tileY2; ty++) {
      for (let tx = tileX1; tx <= tileX2; tx++) {
        if (ty < 0 || ty >= map.h || tx < 0 || tx >= map.w || !WALKABLE.has(map.tiles[ty][tx])) {
          canMoveY = false; break;
        }
      }
      if (!canMoveY) break;
    }
    if (canMoveY) player.y = ny;
  }

  // Record player position in trail
  trail.push({x: player.x, y: player.y});
  const maxTrail = TRAIL_SPACING * followers.length + 10;
  if (trail.length > maxTrail) trail.splice(0, trail.length - maxTrail);

  // Update followers from trail
  for (let i = 0; i < followers.length; i++) {
    const f = followers[i];
    if (!f.active) continue;
    // Possession stalling — occasional freeze in Act 3
    if (possessionLevel > 0.3 && Math.random() < possessionLevel * 0.04) {
      f.moving = false;
      continue;
    }
    const trailIdx = trail.length - 1 - TRAIL_SPACING * (i + 1);
    if (trailIdx >= 0) {
      const target = trail[trailIdx];
      const fdx = target.x - f.x;
      const fdy = target.y - f.y;
      const dist = Math.sqrt(fdx * fdx + fdy * fdy);
      if (dist > 1) {
        f.x = target.x;
        f.y = target.y;
        f.moving = true;
        f.animTimer += ANIM_SPEED;
        f.frame = f.animTimer;
        if (Math.abs(fdx) > Math.abs(fdy)) {
          f.dir = fdx > 0 ? 3 : 2;
        } else {
          f.dir = fdy > 0 ? 0 : 1;
        }
      } else {
        f.moving = false;
      }
    }
  }

  // Check map exits
  const px = Math.floor((player.x + 16) / TILE);
  const py = Math.floor((player.y + 20) / TILE);
  for (let exit of map.exits) {
    if (px === exit.x && py === exit.y) {
      if (exit.condition && !exit.condition()) {
        // Show hint
        if (!storyFlags._hintShown) {
          storyFlags._hintShown = true;
          // Brief hint
        }
        continue;
      }
      transitionTarget = exit.targetMap;
      transitionSpawn = { x: exit.spawnX, y: exit.spawnY };
      transitionAlpha = 0;
      gameState = 'transition';
      break;
    }
  }

  // Interact
  if (actionBtn.pressed) {
    tryInteract();
  }

  // Possession increase in Act 3
  if (currentAct === 3) {
    possessionLevel = Math.min(1, possessionLevel + dt * 0.00003);
  }

  // Camera
  cam.x = player.x + 16 - W / 2;
  cam.y = player.y + 16 - H / 2;
  cam.x = Math.max(0, Math.min(cam.x, map.w * TILE - W));
  cam.y = Math.max(0, Math.min(cam.y * 1, map.h * TILE - H));
  if (map.w * TILE < W) cam.x = (map.w * TILE - W) / 2;
  if (map.h * TILE < H) cam.y = (map.h * TILE - H) / 2;

  // Particles
  updateParticles(map);
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  if (gameState === 'title') {
    drawTitle();
    return;
  }

  if (gameState === 'ending') {
    drawEnding();
    return;
  }

  if (gameState === 'boss') {
    drawBossFight();
    return;
  }

  const map = MAPS[currentMap];

  // Draw tiles
  const startX = Math.max(0, Math.floor(cam.x / TILE));
  const startY = Math.max(0, Math.floor(cam.y / TILE));
  const endX = Math.min(map.w - 1, Math.ceil((cam.x + W) / TILE));
  const endY = Math.min(map.h - 1, Math.ceil((cam.y + H) / TILE));

  for (let y = startY; y <= endY; y++) {
    for (let x = startX; x <= endX; x++) {
      drawTile(x, y, map.tiles[y][x], currentMap);
    }
  }

  // Glen's footprints (forest only, on ground under entities)
  drawFootprints();

  // Draw entities sorted by Y
  let entities = [];
  entities.push({ y: player.y, type: 'player' });
  for (let npc of map.npcs) {
    // Skip NPCs that are now active followers
    if (npc.id === 'rina' && followers[0].active) continue;
    if (npc.id === 'kenji' && followers[1].active) continue;
    entities.push({ y: npc.y, type: 'npc', npc });
  }
  for (let f of followers) {
    if (f.active) entities.push({ y: f.y, type: 'follower', follower: f });
  }
  entities.sort((a, b) => a.y - b.y);

  for (let e of entities) {
    if (e.type === 'player') {
      drawCharSprite(player.x, player.y, player.char, player.dir, player.frame, false);
    } else if (e.type === 'follower') {
      drawCharSprite(e.follower.x, e.follower.y, e.follower.char, e.follower.dir, e.follower.frame, false);
      // Possession dark overlay in Act 3
      if (possessionLevel > 0.1) {
        const fx = e.follower.x - cam.x + 16, fy = e.follower.y - cam.y + 20;
        ctx.fillStyle = `rgba(80,20,120,${possessionLevel * 0.35})`;
        ctx.beginPath();
        ctx.ellipse(fx, fy, 12, 14, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (e.npc.isObject) {
      drawObjectSprite(e.npc.x, e.npc.y, e.npc.sprite);
    } else {
      const isNear = nearbyInteractable() === e.npc;
      drawCharSprite(e.npc.x, e.npc.y, e.npc.char, e.npc.dir || 0, 0, isNear);
    }
  }

  // Particles on top
  drawParticles();

  // Darkness overlay for forest
  if (map.darkness) {
    ctx.fillStyle = `rgba(10,5,25,${map.darkness})`;
    ctx.fillRect(0, 0, W, H);
    // Spotlight around player
    const px = player.x + 16 - cam.x, py = player.y + 16 - cam.y;
    const grad = ctx.createRadialGradient(px, py, 30, px, py, 180);
    grad.addColorStop(0, 'rgba(10,5,25,0.35)');
    grad.addColorStop(1, 'rgba(10,5,25,0)');
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
    ctx.globalCompositeOperation = 'source-over';
  }

  // UI
  drawUI();

  // Dialogue
  if (gameState === 'dialogue') {
    drawDialogue();
  }

  // Transition overlay
  if (gameState === 'transition' || gameState === 'fadein') {
    ctx.fillStyle = `rgba(0,0,0,${transitionAlpha})`;
    ctx.fillRect(0, 0, W, H);
  }
}

// ── TITLE SCREEN ──
function drawTitle() {
  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a2e');
  grad.addColorStop(0.5, '#2d1b4e');
  grad.addColorStop(1, '#0a0a1a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  const tt = Date.now() * 0.001;
  for (let i = 0; i < 50; i++) {
    const sx = ((i * 137.5) % W);
    const sy = ((i * 97.3 + i * i * 3.7) % (H * 0.6));
    const alpha = 0.3 + Math.sin(tt + i * 0.5) * 0.3;
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.beginPath();
    ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Portal glow
  const glowY = H * 0.35;
  ctx.fillStyle = `rgba(100,40,200,${0.15 + Math.sin(tt * 2) * 0.05})`;
  ctx.beginPath();
  ctx.arc(W/2, glowY, 100 + Math.sin(tt) * 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = `rgba(160,80,255,${0.1 + Math.sin(tt * 1.5) * 0.05})`;
  ctx.beginPath();
  ctx.arc(W/2, glowY, 60 + Math.sin(tt * 1.3) * 5, 0, Math.PI * 2);
  ctx.fill();

  // Title
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 42px "Segoe UI", "Helvetica Neue", sans-serif';
  ctx.fillText(t('title_name'), W/2, H * 0.38);

  // Subtitle
  ctx.fillStyle = '#c8b8ff';
  ctx.font = '18px "Segoe UI", sans-serif';
  const subtitleKey = currentAct === 1 ? 'title_subtitle' : currentAct === 2 ? 'title_subtitle_act2' : 'title_subtitle_act3';
  ctx.fillText(t(subtitleKey), W/2, H * 0.45);

  // Characters silhouettes
  const chars = [CHARS.hikaru, CHARS.rina, CHARS.kenji];
  const portraitSize = 50;
  for (let i = 0; i < 3; i++) {
    const px = W/2 + (i - 1) * 70;
    drawPortrait(chars[i], px - portraitSize/2, H * 0.52, portraitSize);
  }

  // Tap to start
  const startAlpha = 0.5 + Math.sin(tt * 3) * 0.3;
  ctx.fillStyle = `rgba(200,180,255,${startAlpha})`;
  ctx.font = '16px "Segoe UI", sans-serif';
  ctx.fillText(t('title_tap'), W/2, H * 0.78);

  // Credits
  ctx.fillStyle = 'rgba(150,130,200,0.5)';
  ctx.font = '11px "Segoe UI", sans-serif';
  ctx.fillText(t('title_credit'), W/2, H * 0.92);

  // Language selector
  const btnW = 44, btnH = 28, gap = 8;
  const totalW = btnW * 3 + gap * 2;
  const lx = W/2 - totalW/2, ly = 14;
  const langs = ['tr', 'en', 'ru'];
  const labels = ['TR', 'EN', 'RU'];
  for (let i = 0; i < 3; i++) {
    const bx = lx + i * (btnW + gap);
    const selected = lang === langs[i];
    ctx.fillStyle = selected ? 'rgba(160,100,255,0.7)' : 'rgba(60,40,100,0.5)';
    ctx.beginPath();
    ctx.roundRect(bx, ly, btnW, btnH, 6);
    ctx.fill();
    ctx.strokeStyle = selected ? 'rgba(200,160,255,0.9)' : 'rgba(120,100,180,0.4)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(bx, ly, btnW, btnH, 6);
    ctx.stroke();
    ctx.fillStyle = selected ? '#fff' : 'rgba(200,180,255,0.6)';
    ctx.font = 'bold 13px "Segoe UI", sans-serif';
    ctx.fillText(labels[i], bx + btnW/2, ly + btnH/2 + 5);
  }

  ctx.textAlign = 'start';
}

// ── ENDING SCREEN ──
function drawEnding() {
  const progress = Math.min(endingTimer / 8000, 1);

  // Background — darker for later acts
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  if (currentAct === 1) { grad.addColorStop(0, '#0a0520'); grad.addColorStop(1, '#2a1050'); }
  else if (currentAct === 2) { grad.addColorStop(0, '#200a10'); grad.addColorStop(1, '#100520'); }
  else { grad.addColorStop(0, '#0a0008'); grad.addColorStop(1, '#050005'); }
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Portal effect
  const tt = Date.now() * 0.002;
  for (let i = 0; i < 8; i++) {
    const a = tt + i * Math.PI / 4;
    const r = 60 + Math.sin(tt + i) * 20;
    ctx.fillStyle = `rgba(160,80,255,${0.1 + Math.sin(tt + i * 0.5) * 0.05})`;
    ctx.beginPath();
    ctx.arc(W/2 + Math.cos(a) * r, H * 0.3 + Math.sin(a) * r * 0.6, 30 + Math.sin(tt * 2 + i) * 10, 0, Math.PI * 2);
    ctx.fill();
  }

  // Select text keys based on act
  const keys = currentAct === 1
    ? { aw:'end_awaits', l1:'end_line1', l2:'end_line2', ac:'end_act', co:'end_cont' }
    : currentAct === 2
    ? { aw:'end2_sacrifice', l1:'end2_line1', l2:'end2_line2', ac:'end2_act', co:'end2_cont' }
    : { aw:'end3_reveal', l1:'end3_line1', l2:'end3_line2', ac:'end3_act', co:'end3_cont' };

  ctx.textAlign = 'center';

  if (progress > 0.1) {
    const alpha = Math.min((progress - 0.1) * 3, 1);
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.font = 'bold 28px "Segoe UI", sans-serif';
    ctx.fillText(t(keys.aw), W/2, H * 0.35);
  }

  if (progress > 0.35) {
    const alpha = Math.min((progress - 0.35) * 3, 1);
    ctx.fillStyle = `rgba(200,180,255,${alpha})`;
    ctx.font = '16px "Segoe UI", sans-serif';
    ctx.fillText(t(keys.l1), W/2, H * 0.45);
    ctx.fillText(t(keys.l2), W/2, H * 0.50);
  }

  if (progress > 0.55) {
    const alpha = Math.min((progress - 0.55) * 3, 1);
    const portraitChars = currentAct === 2 ? [CHARS.glen] : [CHARS.hikaru, CHARS.rina, CHARS.kenji];
    const portraitSize = 55;
    for (let i = 0; i < portraitChars.length; i++) {
      ctx.globalAlpha = alpha;
      const px = W/2 + (i - (portraitChars.length-1)/2) * 80;
      drawPortrait(portraitChars[i], px - portraitSize/2, H * 0.56, portraitSize);
    }
    ctx.globalAlpha = 1;
  }

  if (progress > 0.75) {
    const alpha = Math.min((progress - 0.75) * 3, 1);
    ctx.fillStyle = `rgba(255,200,100,${alpha})`;
    ctx.font = 'bold 22px "Segoe UI", sans-serif';
    ctx.fillText(t(keys.ac), W/2, H * 0.80);
    ctx.fillStyle = `rgba(200,180,255,${alpha * 0.7})`;
    ctx.font = '14px "Segoe UI", sans-serif';
    ctx.fillText(t(keys.co), W/2, H * 0.86);
  }

  // Tap to continue for Acts 1 and 2
  if (progress >= 1 && currentAct < 3) {
    const blinkAlpha = 0.4 + Math.sin(Date.now() * 0.004) * 0.3;
    ctx.fillStyle = `rgba(200,180,255,${blinkAlpha})`;
    ctx.font = '14px "Segoe UI", sans-serif';
    ctx.fillText(t('ui_tap_continue'), W/2, H * 0.93);
  }

  ctx.textAlign = 'start';
}

// ── INIT ──
function init() {
  player.x = 5 * TILE;
  player.y = 8 * TILE;
  currentMap = 'neighborhood';
  objective = t('obj_talk_friends');
  // Seed trail for followers
  trail = [];
  for (let i = 0; i < TRAIL_SPACING * followers.length + 10; i++) trail.push({x: player.x, y: player.y});
  initParticles(MAPS[currentMap].particles);
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
